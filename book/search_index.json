[["index.html", "Circular Visualization in R About", " Circular Visualization in R Zuguang Gu last revised on 2020-11-27 About This is the documentation of the circlize package. Examples in the book are generated under version 0.4.12.1004. If you use circlize in your publications, I am appreciated if you can cite: Gu, Z. (2014) circlize implements and enhances circular visualization in R. Bioinformatics. DOI: 10.1093/bioinformatics/btu393 Session info: sessionInfo() ## R version 4.0.2 (2020-06-22) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Catalina 10.15.5 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] circlize_0.4.12.1004 ## ## loaded via a namespace (and not attached): ## [1] bookdown_0.21 digest_0.6.27 grid_4.0.2 ## [4] magrittr_2.0.1 evaluate_0.14 rlang_0.4.8 ## [7] stringi_1.5.3 GlobalOptions_0.1.2 rmarkdown_2.5 ## [10] tools_4.0.2 stringr_1.4.0 xfun_0.19 ## [13] yaml_2.2.1 compiler_4.0.2 colorspace_2.0-0 ## [16] shape_1.4.5 htmltools_0.5.0 knitr_1.30 "],["introduction.html", "Chapter 1 Introduction 1.1 Principle of design 1.2 A quick glance", " Chapter 1 Introduction Circular layout is very useful to represent complicated information. First, it elegantly represents information with long axes or a large amount of categories; second, it intuitively shows data with multiple tracks focusing on the same object; third, it easily demonstrates relations between elements. It provides an efficient way to arrange information on the circle and it is beautiful. Circos is a pioneer tool widely used for circular layout representations implemented in Perl. It greatly enhances the visualization of scientific results (especially in Genomics field). Thus, plots with circular layout are normally named as “circos plot”. Here the circlize package aims to implement Circos in R. One important advantage for the implementation in R is that R is an ideal environment which provides seamless connection between data analysis and data visualization. circlize is not a front-end wrapper to generate configuration files for Circos, while completely coded in R style by using R’s elegant statistical and graphic engine. We aim to keep the flexibility and configurability of Circos, but also make the package more straightforward to use and enhance it to support more types of graphics. In this book, chapters in Part I give detailed overviews of the general circlize functionalities. Part II introduces functions specifically designed for visualizing genomic datasets. Part III gives comprehensive guilds on visualizing relationships by Chord diagram. 1.1 Principle of design A circular layout is composed of sectors and tracks. For data in different categories, they are allocated into different sectors, and for multiple measurements on the same category, they are represented as stacked tracks from outside of the circle to the inside. The intersection of a sector and a track is called a cell (or a grid, a panel), which is the basic unit in a circular layout. It is an imaginary plotting region for drawing data points. Since most of the figures are composed of simple graphics, such as points, lines, polygon, circlize implements low-level graphic functions for adding graphics in the circular plotting regions, so that more complicated graphics can be easily generated by different combinations of low-level graphic functions. This principle ensures the generality that types of high-level graphics are not restricted by the software itself and high-level packages focusing on specific interests can be built on it. Currently there are following low-level graphic functions that can be used for adding graphics. The usage is very similar to the functions without circos. prefix from the base graphic engine, except there are some enhancement specifically designed for circular visualization. circos.points(): adds points in a cell. circos.lines(): adds lines in a cell. circos.segments(): adds segments in a cell. circos.rect(): adds rectangles in a cell. circos.polygon(): adds polygons in a cell. circos.text(): adds text in a cell. circos.axis() ands circos.yaxis(): add axis in a cell. Following function draws links between two positions in the circle: circos.link() Following functions draw high-level graphics: circos.barplot(): draw barplots. circos.boxplot(): draw boxplots. circos.violin(): draws violin plots. circos.heatmap(): draw circular heatmaps. circos.raster(): draw raster images. circos.arrow(): draw circular arrows. Following functions arrange the circular layout. circos.initialize(): allocates sectors on the circle. circos.track(): creates plotting regions for cells in one single track. circos.update(): updates an existed cell. circos.par(): graphic parameters. circos.info(): prints general parameters of current circular plot. circos.clear(): resets graphic parameters and internal variables. Thus, theoretically, you are able to draw most kinds of circular figures by the above functionalities. Figure 1.1 lists several complex circular plots made by circlize. After going through this book, you will definitely be able to implement yours. Figure 1.1: Examples by circlize 1.2 A quick glance Before we go too deep into the details, I first demonstrate a simple example with using basic functionalities in circlize package to help you to get a basic idea of how the package works. First let’s generate some random data. There needs a character vector to represent categories, a numeric vector of x values and a vectoe of y values. set.seed(999) n = 1000 df = data.frame(sectors = sample(letters[1:8], n, replace = TRUE), x = rnorm(n), y = runif(n)) First we initialize the circular layout. The circle is split into sectors based on the data range on x-axes in each category. In following code, df$x is split by df$sectors and the width of sectors are automatically calculated based on data ranges in each category. Be default, sectors are positioned started from \\(\\theta = 0\\) (in the polar coordinate system) and go along the circle clock-wisely. You may not see anything after running following code because no track has been added yet. library(circlize) circos.par(&quot;track.height&quot; = 0.1) circos.initialize(df$sectors, x = df$x) We set a global parameter track.height to 0.1 by the option function circis.par() so that all tracks which will be added have a default height of 0.1. The circle used by circlize always has a radius of 1, so a height of 0.1 means 10% of the circle radius. In later chapters, you can find how to set the height with physical units, e.g. cm. Note that the allocation of sectors only needs values on x direction (or on the circular direction), the values on y direction (radical direction) will be used in the step of creating tracks. After the circular layout is initialized, graphics can be added to the plot in a track-by-track manner. Before drawing anything, we need to know that all tracks should be first created by circos.trackPlotRegion() or, for short, circos.track(), then the low-level functions can be added afterwards. Just think in the base R graphic engine, you need first call plot() then you can use functions such as points() and lines() to add graphics. Since x-ranges for cells in the track have already been defined in the initialization step, here we only need to specify the y-range for each cell. The y-ranges can be specified by y argument as a numeric vector (so that y-range will be automatically extracted and calculated in each cell) or ylim argument as a vector of length two. In principle, y-ranges should be same for all cells in a same track. (See Figure 1.2) circos.track(df$sectors, y = df$y, panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$cell.ylim[2] + mm_y(5), CELL_META$sector.index) circos.axis(labels.cex = 0.6) }) col = rep(c(&quot;#FF0000&quot;, &quot;#00FF00&quot;), 4) circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5) circos.text(-1, 0.5, &quot;text&quot;, sector.index = &quot;a&quot;, track.index = 1) Figure 1.2: First example of circlize, add the first track. Axes for the circular plot are normally drawn on the most outside of the circle. Here we add axes in the first track by putting circos.axis() inside the self-defined function panel.fun (see the code above). circos.track() creates plotting region in a cell-by-cell manner and the panel.fun is actually executed immediately after the plotting region for a certain cell is created. Thus, panel.fun actually means adding graphics in the “current cell” (Usage of panel.fun is further discussed in Section 2.7). Without specifying any arguments, circos.axis() draws x-axes on the top of each cell (or the outside of each cell). Also, we add sector name outside the first track by using circos.text(). CELL_META provides “meta information” for the current cell. There are several parameters which can be retrieved by CELL_META. All its usage is explained in Section 2.7. In above code, the sector names are drawn outside the cells and you may see warning messages saying data points exceeding the plotting regions. That is total fine and no worry about it. You can also add sector names by creating an empty track without borders as the first track and add sector names in it (like what circos.initializeWithIdeogram() and chordDiagram() do, after you go through following chapters). When specifying the position of text on the y direction, an offset of mm_y(5) (5mm) is added to the y position of the text. In circos.text(), x and y values are measured in the data coordinate (the coordinate in cell), and there are some helper functions that convert absolute units to corresponding values in data coordinate. Section 2.8.2 provides more information of converting units in different coordinates. After the track is created, points are added to the first track by circos.trackPoints(). circos.trackPoints() simply adds points in all cells simultaneously. As further explained in Section 3.2, it can be replaced by putting circos.text() in panel.fun, however, circos.trackPoints() would be more convenient if only the points are needed to put in the cells (but I don’t really recommend). It is quite straightforward to understand that this function needs a categorical variable (df$sectors), values on x direction and y direction (df$x and df$y). Low-level functions such as circos.text() can also be used outside panel.fun as shown in above code. If so, sector.index and track.index need to be specified explicitly because the “current” sector and “current” track may not be what you want. If the graphics are directly added to the track which are most recently created, track.index can be ommitted because this track is just marked as the “current” track. OK, now we add histograms to the second track. Here circos.trackHist() is a high-level function which means it creates a new track (as you can imagin hist() is also a high-level function). bin.size is explicitly set so that the bin size for histograms in all cells are the same and can be compared to each other. (See Figure 1.3) bgcol = rep(c(&quot;#EFEFEF&quot;, &quot;#CCCCCC&quot;), 4) circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA) Figure 1.3: First example of circlize, add the second track. In the third track and in panel.fun, we randomly picked 10 data points in each cell, sort them by x-values and connect them with lines. In following code, when sectors (the first unnamed argument), x and y arguments are set in circos.track(), x values and y values are split by df$sectors and corresponding subset of x and y values are sent to panel.fun through panel.fun’s x and y arguments. Thus, x an y in panel.fun are exactly the values in the “current” cell. (See Figure 1.4) circos.track(df$sectors, x = df$x, y = df$y, panel.fun = function(x, y) { ind = sample(length(x), 10) x2 = x[ind] y2 = y[ind] od = order(x2) circos.lines(x2[od], y2[od]) }) Figure 1.4: First example of circlize, add the third track. Now we go back to the second track and update the cell in sector “d”. This is done by circos.updatePlotRegion() or the short version circos.update(). The function erases graphics which have been added. circos.update() can not modify the xlim and ylim of the cell as well as other settings related to the position of the cell. circos.update() needs to explicitly specify the sector index and track index unless the “current” cell is what you want to update. After the calling of circos.update(), the “current” cell is redirected to the cell you just specified and you can use low-level graphic functions to add graphics directly into it. (See Figure 1.5) circos.update(sector.index = &quot;d&quot;, track.index = 2, bg.col = &quot;#FF8080&quot;, bg.border = &quot;black&quot;) circos.points(x = -2:2, y = rep(0.5, 5), col = &quot;white&quot;) circos.text(CELL_META$xcenter, CELL_META$ycenter, &quot;updated&quot;, col = &quot;white&quot;) Figure 1.5: First example of circlize, update the second track. Next we continue to create new tracks. Although we have gone back to the second track, when creating a new track, the new track is still created after the track which is most inside. In this new track, we add heatmaps by circos.rect(). Note here we haven’t set the input data, while simply set ylim argument because heatmaps just fill the whole cell from the most left to right and from bottom to top. Also the exact value of ylim is not important and x, y in panel.fun() are not used (actually they are both NULL). (See Figure 1.6) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { xlim = CELL_META$xlim ylim = CELL_META$ylim breaks = seq(xlim[1], xlim[2], by = 0.1) n_breaks = length(breaks) circos.rect(breaks[-n_breaks], rep(ylim[1], n_breaks - 1), breaks[-1], rep(ylim[2], n_breaks - 1), col = rand_color(n_breaks), border = NA) }) Figure 1.6: First example of circlize, add the fourth track. In the most inside of the circle, links or ribbons are added. There can be links from single point to point, point to interval or interval to interval. Section 3.11 gives detailed usage of links. (See Figure 1.7) circos.link(&quot;a&quot;, 0, &quot;b&quot;, 0, h = 0.4) circos.link(&quot;c&quot;, c(-0.5, 0.5), &quot;d&quot;, c(-0.5,0.5), col = &quot;red&quot;, border = &quot;blue&quot;, h = 0.2) circos.link(&quot;e&quot;, 0, &quot;g&quot;, c(-1,1), col = &quot;green&quot;, border = &quot;black&quot;, lwd = 2, lty = 2) Figure 1.7: First example of circlize, add links. Finally we need to reset the graphic parameters and internal variables, so that it will not mess up your next plot. circos.clear() "],["circular-layout.html", "Chapter 2 Circular layout 2.1 Coordinate transformation 2.2 Rules for making the circular plot 2.3 Sectors and tracks 2.4 Graphic parameters 2.5 Create plotting regions 2.6 Update plotting regions 2.7 panel.fun argument 2.8 Other utilities 2.9 Set gaps between tracks", " Chapter 2 Circular layout 2.1 Coordinate transformation To map graphics onto the circle, there exist transformations among several coordinate systems. First, there are data coordinate systems in which ranges for x-axes and y-axes are the ranges of original data. Second, there is a polar coordinate system in which these coordinates are mapped onto a circle. Finally, there is a canvas coordinate system in which graphics are really drawn on the graphic device (Figure 2.1). Each cell has its own data coordinate and they are independent. circlize first transforms coordinates from data coordinate system to polar coordinate system and finally transforms into canvas coordinate system. For users, they only need to imagine that each cell is a normal rectangular plotting region (data coordinate) in which x-lim and y-lim are ranges of data in that cell. circlize knows which cell you are in and does all the transformations automatically. Figure 2.1: Transformation between different coordinates The final canvas coordinate is in fact an ordinary coordinate in the base R graphic system with x-range in (-1, 1) and y-range in (-1, 1) by default. It should be noted that the circular plot is always drawn inside the circle which has radius of 1 (which means it is always a unit circle), and from outside to inside. 2.2 Rules for making the circular plot The rule for making the circular plot is rather simple. It follows the sequence of initialize layout -&gt; create track -&gt; add graphics -&gt; create track -&gt; add graphics - ... -&gt; clear. Graphics can be added at any time as long as the tracks are created. Details are shown in Figure 2.2 and as follows: Figure 2.2: Order of drawing circular layout. Initialize the layout using circos.initialize(). Since circular layout in fact visualizes data which is in categories, there must be at least a categorical variable. Ranges of x values on each category can be specified as a vector or the range itself. See Section 2.3. Create plotting regions for the new track and add graphics. The new track is created just inside the previously created one. Only after the creation of the track can you add other graphics on it. There are three ways to add graphics in cells. After the creation of the track, use low-level graphic function like circos.points(), circos.lines(), … to add graphics cell by cell. It always involves a for loop and you need to subset the data by the categorical variable manually. Use circos.trackPoints(), circos.trackLines(), … to add simple graphics through all cells simultaneously. Use panel.fun argument in circos.track() to add graphics immediately after the creation of a certain cell. panel.fun needs two arguments x and y which are x values and y values that are in the current cell. This subset operation is applied automatically. This is the most recommended way. Section 2.7 gives detailed explanation of using panel.fun argument. Repeat step 2 to add more tracks on the circle unless it reaches the center of the circle. Call circos.clear() to clean up. As mentioned above, there are three ways to add graphics on a track. Create plotting regions for the whole track first and then add graphics by specifying sector.index. In the following pseudo code, x1, y1 are data points in a given cell, which means you need to do data subsetting manually. In following code, circos.points() and circos.lines() are used separatedly from circos.track(), thus, the index for the sector needs to be explicitly specified by sector.index argument. There is also a track.index argument for both functions, however, the default value is the “current” track index and as the two functions are used just after circos.track(), the “current” track index is what the two functions expect and it can be ommited when calling the two functions. circos.initialize(sectors, xlim) circos.track(ylim) for(sector.index in all.sector.index) { circos.points(x1, y1, sector.index) circos.lines(x2, y2, sector.index) } Add graphics in a batch mode. In following code, circos.trackPoints() and circos.trackLines() need a categorical variable, a vector of x values and a vector of y values. X and y values will be split by the categorical variable and sent to corresponding cell to add the graphics. Internally, this is done by using circos.points() or circos.lines() in a for loop. This way to add graphics would be convenient if users only want to add a specific type of simple graphics (e.g. only points) to the track, but it is not recommended for making complex graphics. circos.trackPoints() and circos.trackLines() need a track.index to specify which track to add the graphics. Similarly, since these two are called just after circos.track(), the graphics are added in the newly created track right away. circos.initialize(sectors, xlim) circos.track(ylim) circos.trackPoints(sectors, x, y) circos.trackLines(sectors, x, y) Use a panel function to add self-defined graphics as soon as the cell has been created. This is the way recommended and you can find most of the code in this book uses panel.fun. circos.track() creates cells one by one and after the creation of a cell, and panel.fun is executed on this cell immediately. In this case, the “current” sector and “current” track are marked to this cell that you can directly use low-level functions without specifying sector index and track index. If you look at following code, you will find the code inside panel.fun is as natural as using points() or lines() in the normal R graphic system. This is a way to help you think a cell is an “imaginary rectangular plotting region”. circos.initialize(sectors, xlim) circos.track(sectors, all_x, all_y, ylim, panel.fun = function(x, y) { circos.points(x, y) circos.lines(x, y) }) There are several internal variables keeping tracing of the current sector and track when applying circos.track() and circos.update(). Thus, although functions like circos.points(), circos.lines() need to specify the index of sector and track, they will take the current one by default. As a result, if you draw points, lines, text et al just after the creation of the track or cell, you do not need to set the sector index and the track index explicitly and it will be added in the most recently created or updated cell. 2.3 Sectors and tracks A circular layout is composed of sectors and tracks. As illustrated in Figure 2.3, the red circle is one track and the blue represents one sector. The intersection of a sector and a track is called a cell which can be thought as an imaginary plotting region for data points. In this section, we introduce how to set data ranges on x and y directions in cells. Figure 2.3: Sectors and tracks in circular layout. Sectors are first allocated on the circle by circos.initialize(). There must be a categorical variable (say sectors) that on the circle, each sector corresponds to one category. The width of sectors (measured by degree) are proportional to the data range in sectors on x direction (or the circular direction). The data range can be specified as a numeric vector x which has same length as sectors, then x is split by sectors and data ranges are calculated for each sector internally. Data ranges can also be specified directly by xlim argument. The valid value for xilm is a two-column matrix with same number of rows as number of sectors that each row in xlim corresponds to one sector. If xlim has row names which already cover sector names, row order of xlim is automatically adjusted. If xlim is a vector of length two, all sectors have the same x range. circos.initialize(sectors, x = x) circos.initialize(sectors, xlim = xlim) If sectors is not specified, the row names of xlim are taken as the value for sectors. circos.initialize(xlim = xlim) After the initialization of the layout, you may not see anything drawn or only an empty graphical device is opened. That is because no track has been created yet, however, the layout has already been recorded internally. In the initialization step, not only the width of each sector is assigned, but also the order of sectors on the circle is determined. Order of the sectors are determined by the order of levels of the input factor. If the value for sectors is not a factor, the order of sectors is unique(sectors). Thus, if you want to change the order of sectors, you can just change of the level of sectors variable. The following code generates plots with different sector orders (Figure 2.4). sectors = c(&quot;d&quot;, &quot;f&quot;, &quot;e&quot;, &quot;c&quot;, &quot;g&quot;, &quot;b&quot;, &quot;a&quot;) s1 = factor(sectors) circos.initialize(s1, xlim = c(0, 1)) s2 = factor(sectors, levels = sectors) circos.initialize(s2, xlim = c(0, 1)) Figure 2.4: Different sector orders. In different tracks, cells in the same sector share the same data range on x-axes. Then, for each track, we only need to specify the data range on y direction (or the radical direction) for cells. Similar as circos.initialize(), circos.track() also receives either y or ylim argument to specify the range of y-values. Since all cells in a same track share a same y range, ylim is just a vector of length two if it is specified. x can also be specified in circos.track(), but it is only used to send to panel.fun. In Section 2.7, we will introduce how x and y are sent to each cell and how the graphics are added. circos.track(sectors, y = y) circos.track(sectors, ylim = c(0, 1)) circos.track(sectors, x = x, y = y) In the track creation step, since all sectors have already been allocated in the circle, if sectors argument is not set, circos.track() would create plotting regions for all available sectors. Also, levels of sectors do not need to be specified explicitly because the order of sectors has already be determined in the initialization step. If users only create cells for a subset of sectors in the track (not all sectors), in fact, cells in remaining unspecified sectors are created as well, but with no borders (pretending they are not created). # assume `sectors` only covers a subset of sectors # You will only see cells that are covered in `sectors` have borders circos.track(sectors, y = y) # You will see all cells have borders circos.track(ylim = c(0, 1)) circos.track(ylim = ranges(y)) Cells are basic units in the circular plot and are independent from each other. After the creation of cells, they have self-contained meta values of x-lim and y-lim (data range measured in data coordinate). So if you are adding graphics in one cell, you do not need to consider things outside the cell and also you do not need to consider you are in the circle. Just pretending it is normal rectangle region with its own coordinate. Figure 2.5: Sector directions. Figure 2.6: Axes directions. 2.4 Graphic parameters Some basic parameters for the circular layout can be set by circos.par(). These parameters are listed as follows. Note some parameters can only be modified before the initialization of the circular layout. start.degree: The starting degree where the first sector is put. Note this degree is measured in the standard polar coordinate system which means it is always reverse clockwise. E.g. if it is set to 90, sectors start from the top center of the circle. See Figure 2.5. gap.degree: Gap between two neighbour sectors. It can be a single value which means all gaps share same degree, or a vector which has same number as sectors. Note the first gap is after the first sector. See Figure 2.5 and Figure 2.7. gap.after: Same as gap.degree, but more understandable. Modifying values of gap.after will also modify gap.degree and vice versa. track.margin: Like margin in Cascading Style Sheets (CSS), it is the blank area out of the plotting region, also outside of the borders. Since left and right margin are controlled by gap.after, only bottom and top margin need to be set. The value for track.margin is the percentage to the radius of the unit circle. The value can also be set by mm_h()/cm_h()/inches_h() functions with absolute units. See Figure 2.7. cell.padding: Padding of the cell. Like padding in Cascading Style Sheets (CSS), it is the blank area around the plotting regions, but within the borders. The parameter has four values, which control the bottom, left, top and right padding respectively. The first and the third padding values are the percentages to the radius of the unit circle, and the second and fourth values are the degrees. The first and the third value can be set by mm_h()/cm_h()/inches_h() with absolute units. See Figure 2.7. unit.circle.segments: Since curves are simulated by a series of straight lines, this parameter controls the amount of segments to represent a curve. The minimal length of the line segment is the length of the unit circle (\\(2\\pi\\)) divided by unit.circle.segments. More segments means better approximation for the curves, while generate larger file size if figures are in PDF format. See explanantion in Section 3.3. track.height: The default height of tracks. It is the percentage to the radius of the unit circle. The height includes the top and bottom cell paddings but not the margins. The value can be set by mm_h()/cm_h()/inches_h() with absolute units. points.overflow.warning: Since each cell is in fact not a real plotting region but only an ordinary rectangle (or more precisely, a circular rectangle), it does not remove points that are plotted outside of the region. So if some points (or lines, text) are out of the plotting region, by default, the package would continue drawing the points but with warning messages. However, in some circumstances, drawing something out of the plotting region is useful, such as adding some text annotations (like the first track in Figure 1.2). Set this value to FALSE to turn off the warnings. canvas.xlim: The ranges in the canvas coordinate in x direction. circlize is forced to put everything inside the unit circle, so canvas.xlim and canvas.ylim is c(-1, 1) by default. However, you can set it to a more broad interval if you want to leave more spaces out of the circle. By choosing proper canvas.xlim and canvas.ylim, actually you can customize the circle. E.g. setting canvas.xlim to c(0, 1) and canvas.ylim to c(0, 1) would only draw 1/4 of the circle. canvas.ylim: The ranges in the canvas coordinate in y direction. circle.margin: Margin in the horizontal and vertical direction. The value should be a positive numeric vector and the length of it should be either 1, 2, or 4. When it has length of 1, it controls the margin on the four sides of the circle. When it has length of 2, the first value controls the margin on the left and right, and the second value controls the margin on the bottom and top side. When it has length of 4, the four values controls the margins on the left, right, bottom and top sides of the circle. So A value of c(x1, x2, y1, y2) means circos.par(canvas.xlim = c(-(1+x1), 1+x2), canvas.ylim = c(-(1+y1), 1+y2)). clock.wise: The order for drawing sectors. Default is TRUE which means clockwise (Figure 2.5. xaxis.clock.wise: The direction of x-axis in each cell. By default it is clockwise. Note this new parameter was only available from version 0.4.11 (Figure 2.6). Also see more details on this blog post. Figure 2.7: Regions in a cell. Default values for graphic parameters are listed in following table. start.degree 0 gap.degree/gap.after 1 track.margin c(0.01, 0.01) cell.padding c(0.02, 1.00, 0.02, 1.00) unit.circle.segments 500 track.height 0.2 points.overflow.warning TRUE canvas.xlim c(-1, 1) canvas.ylim c(-1, 1) circle.margin c(0, 0, 0, 0) clock.wise TRUE xaxis.clock.wise TRUE Parameters related to the allocation of sectors cannot be changed after the initialization of the circular layout. Thus, start.degree, gap.degree/gap.after, canvas.xlim, canvas.ylim, circle.margin, clock.wise and xaxis.clock.wise can only be modified before circos.initialize(). The second and the fourth values of cell.padding (left and right paddings) can not be modified neither (or will be ignored). Similar reason, since some of the parameters are defined before the initialization of the circular layout, after making each plot, you need to call circos.clear() to manually reset all the parameters. circos.par() can be used in the same way as options(): circos.par(&quot;start.degree&quot; = 30) Or use the $ symbol: circos.par$start.degree = 30 Use RESET to reset all the options to their default values: circos.par(RESET = TRUE) Simply enter circos.par prints the current values of all parameters: circos.par ## Option Value ## -----------------------:------------------ ## start.degree 0 ## gap.degree 1 ## gap.after 1 ## track.margin 0.01, 0.01 ## unit.circle.segments 500 ## cell.padding 0.02, 1, 0.02, 1 ## track.height 0.2 ## points.overflow.warning TRUE ## circle.margin 0, 0, 0, 0 ## canvas.xlim -1, 1 ## canvas.ylim -1, 1 ## major.by.degree 10 ## clock.wise TRUE ## xaxis.clock.wise TRUE ## message TRUE circos.par() is aimed to be designed to be independent to the number or the order of sectors, however, there is an exception. The gap.degree/gap.after parameter controls the spaces between two neighbouring sectors. When it is set as a scalar, the gap is the same to every two neighbouring sectors and it works fine. It can also be a vector which has the same length as the number of sectors and it can cause problems: When you change the order of the sectors, you also need to manually change the order of gap.degree/gap.after. In chordDiagram() function which will be introduced in Section 14, by default the tiny sectors are removed to improve the visualization, which means, the gap.degree should be adjusted. Also in chordDiagram(), sometimes it is not very straightforward to find out the order of sectors, thus, it is difficult to set a proper gap.degree/gap.after. Now, from version 0.4.10, the value of gap.degree/gap.after can be set as a named vector where the names are the names of the sectors. In this case, the gap.degree/gap.after vector can be automatically reordered or subsetted according to the sector ordering in the plot. 2.5 Create plotting regions As described above, only after creating the plotting region can you add low-level graphics in it. The minimal set of arguments for circos.track() is to set either y or ylim which assigns range of y values for this track. circos.track() creates tracks for all sectors although in some case only parts of them are visible. If sectors is not specified, all cells in the track will be created with the same settings. If sectors, x and y are set, they need to be vectors with the same length. Proper values of x and y that correspond to current cell will be passed to panel.fun by subsetting sectors internally. Section 2.7 explains the usage of panel.fun. Graphic arguments such as bg.border and bg.col can either be a scalar or a vector. If it is a vector, the length must be equal to the number of sectors and the order corresponds to the order of sectors. Thus, you can create plot regions with different styles of borders and background colors. If you are confused with the sectors orders, you can also customize the borders and background colors inside panel.fun. get.cell.meta.data(\"cell.xlim\")/CELL_META$cell.xlim and get.cell.meta.data(\"cell.ylim\")/CELL_META$cell.ylim give you dimensions of the plotting region and you can customize plot regions directly by e.g. circos.rect(CELL_META$cell.xlim[1], CELL_META$cell.ylim[1], CELL_META$cell.xlim[2], CELL_META$cell.ylim[2], col = &quot;#FF000040&quot;, border = 1) circos.track() provides track.margin and cell.padding arguments that they only control track margins and cell paddings for the current track. Of course the second and fourth value (the left and the right padding) in cell.padding are ignored. 2.6 Update plotting regions circos.track() creates new tracks, however, if track.index argument is set to a track which already exists, circos.track() actually re-creates this track. In this case, coordinates on y directions can be re-defined, but settings related to the positions of the track such as the height of the track can not be modified. circos.track(sectors, ylim = c(0, 1), track.index = 1, ...) For a single cell, circos.update() can be used to erase all graphics that have been already added in the cell. However, the data coordinate in the cell keeps unchanged. circos.update(sector.index, track.index) circos.points(x, y, sector.index, track.index) 2.7 panel.fun argument The panel.fun argument in circos.track() is extremely useful to apply plotting as soon as the cell has been created. This self-defined function needs two arguments x and y which are data points that belong to this cell. The value for x and y are automatically extracted from x and y in circos.track() according to the category defined in sectors. In the following example, inside panel.fun, in sector a, the value of x is 1:3 and in sector b, value of x is 4:5. If x or y in circos.track() is NULL, then x or y inside panel.fun is also NULL. sectors = c(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;) x = 1:5 y = 5:1 circos.track(sectors, x = x, y = y, panel.fun = function(x, y) { circos.points(x, y) }) Since you can obtain the current sector index in panel.fun, you can ignore the values from the x and y arguments, while do subsetting by your own: sectors = c(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;) x2 = 1:5 y2 = 5:1 circos.track(ylim = range(y), panel.fun = function(x, y) { # here x and y are useless l = sectors == CELL_META$sector.index circos.points(x2[l], y2[l]) }) In panel.fun, one thing important is that if you use any low-level graphic functions, you don’t need to specify sector.index and track.index explicitly. Remember that when applying circos.track(), cells in the track are created one after one. When a cell is created, circlize would set the sector index and track index of the cell as the ‘current’ index. When the cell is created, panel.fun is executed immediately. Without specifying sector.index and track.index, the ‘current’ ones are used and that’s exactly what you need. The advantage of panel.fun is that it makes you feel you are using graphic functions in the base graphic engine (You can see it is almost the same of using circos.points(x, y) and points(x, y)). It will be much easier for users to understand and customize new graphics. Inside panel.fun, information of the ‘current’ cell can be obtained through get.cell.meta.data(). Also this function takes the ‘current’ sector and ‘current’ track by default. get.cell.meta.data(name) get.cell.meta.data(name, sector.index, track.index) Information that can be extracted by get.cell.meta.data() are: sector.index: The name for the sector. sector.numeric.index: Numeric index for the sector. track.index: Numeric index for the track. xlim: Minimal and maximal values on the x-axis. ylim: Minimal and maximal values on the y-axis. xcenter: mean of xlim. ycenter: mean of ylim. xrange: defined as xlim[2] - xlim[1]. yrange: defined as ylim[2] - ylim[1]. cell.xlim: Minimal and maximal values on the x-axis extended by cell paddings. cell.ylim: Minimal and maximal values on the y-axis extended by cell paddings. xplot: Degree of right and left borders in the plotting region. The values ignore the direction of the circular layout (i.e. whether it is clock wise or not). xplot[1] is always upstream of xplot[2] in the clock-wise direction. yplot: Radius of bottom and top radius in the plotting region. cell.width: Width of the cell, measured in degree. It is calculated as (xplot[1] - xplot[2]) %% 360. cell.height: Height of the cell. Simply yplot[2] - yplot[1]. cell.start.degree: Same as xplot[1]. cell.end.degree: Same as xplot[2]. cell.bottom.radius: Same as yplot[1]. cell.top.radius: Same as yplot[2]. track.margin: Margins of the cell. cell.padding: Paddings of the cell. Following example code uses get.cell.meta.data() to add sector index in the center of each cell. circos.track(ylim = ylim, panel.fun = function(x, y) { sector.index = get.cell.meta.data(&quot;sector.index&quot;) xcenter = get.cell.meta.data(&quot;xcenter&quot;) ycenter = get.cell.meta.data(&quot;ycenter&quot;) circos.text(xcenter, ycenter, sector.index) }) get.cell.meta.data() can also be used outside panel.fun, but you need to explictly specify sector.index and track.index arguments unless the current index is what you want. There is a companion variable CELL_META which is identical to get.cell.meta.data() to get cell meta information, but easier and shorter to write. Actually, the value of CELL_META itself is meaningless, but e.g. CELL_META$sector.index is automatically redirected to get.cell.meta.data(\"sector.index\"). Following code rewrites previous example code with CELL_META. circos.track(ylim = ylim, panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ycenter, CELL_META$sector.index) }) Please note CELL_META only extracts information for the “current” cell, thus, it is recommended to use only in panel.fun. Nevertheless, if you have several lines of code which need to be executed out of panel.fun, you can flag the specified cell as the “current” cell by set.current.cell(), which can save you from typing too many sector.index = ..., track.index = .... E.g. following code circos.text(get.cell.meta.data(&quot;xcenter&quot;, sector.index, track.index), get.cell.meta.data(&quot;ycenter&quot;, sector.index, track.index), get.cell.meta.data(&quot;sector.index&quot;, sector.index, track.index), sector.index, track.index) can be simplified to: set.current.cell(sector.index, track.index) circos.text(get.cell.meta.data(&quot;xcenter&quot;), get.cell.meta.data(&quot;ycenter&quot;), get.cell.meta.data(&quot;sector.index&quot;)) # or even simpler circos.text(CELL_META$xcenter, CELL_META$ycenter, CELL_META$sector.index) 2.8 Other utilities 2.8.1 circlize() and reverse.circlize() circlize transforms data points in several coordinate systems and it is basically done by the core function circlize(). The function transforms from data coordinate (coordinate in the cell) to the polar coordinate and its companion reverse.circlize() transforms from polar coordinate to a specified data coordinate. The default transformation is applied in the current cell. sectors = c(&quot;a&quot;, &quot;b&quot;) circos.initialize(sectors, xlim = c(0, 1)) circos.track(ylim = c(0, 1)) # x = 0.5, y = 0.5 in sector a and track 1 circlize(0.5, 0.5, sector.index = &quot;a&quot;, track.index = 1) ## theta rou ## [1,] 270.5 0.89 # theta = 90, rou = 0.9 in the polar coordinate reverse.circlize(90, 0.9, sector.index = &quot;a&quot;, track.index = 1) ## x y ## [1,] 1.519774 0.56 reverse.circlize(90, 0.9, sector.index = &quot;b&quot;, track.index = 1) ## x y ## [1,] 0.5028249 0.56 You can see the results are different for two reverse.circlize() although it is the same points in the polar coordinate, because they are mapped to different cells. circlize() and reverse.circlize() can be used to connect two circular plots if they are drawn on a same page. This provides a way to build more complex plots. Basically, the two circular plots share a same polar coordiante, then, the manipulation of circlize-&gt;reverse.circlize-&gt;circlize can transform coordinate for data points from the first circular plot to the second. In Chapter 13, we use this technique to combine two circular plots where one zooms subset of regions in the other one. The transformation between polar coordinate and canvas coordinate is simple. circlize has a circlize:::polar2Cartesian() function but this function is not exported. Following example (Figure 2.8) adds raster image to the circular plot. The raster image is added by rasterImage() which is applied in the canvas coordinate. Note how we change coordinate from data coordinate to canvas coordinate by using circlize() and circlize:::polar2Cartesian(). library(yaml) data = yaml.load_file(&quot;https://raw.githubusercontent.com/Templarian/slack-emoji-pokemon/master/pokemon.yaml&quot;) set.seed(123) pokemon_list = data$emojis[sample(length(data$emojis), 40)] pokemon_name = sapply(pokemon_list, function(x) x$name) pokemon_src = sapply(pokemon_list, function(x) x$src) library(EBImage) circos.par(&quot;points.overflow.warning&quot; = FALSE) circos.initialize(pokemon_name, xlim = c(0, 1)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { pos = circlize:::polar2Cartesian(circlize(CELL_META$xcenter, CELL_META$ycenter)) image = EBImage::readImage(pokemon_src[CELL_META$sector.numeric.index]) circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] - mm_y(2), CELL_META$sector.index, facing = &quot;clockwise&quot;, niceFacing = TRUE, adj = c(1, 0.5), cex = 0.6) rasterImage(image, xleft = pos[1, 1] - 0.05, ybottom = pos[1, 2] - 0.05, xright = pos[1, 1] + 0.05, ytop = pos[1, 2]+ 0.05) }, bg.border = 1, track.height = 0.15) Figure 2.8: Add raster image to the circular plot. circos.clear() In circlize package, there is a circos.raster() function which directly adds raster images. It is introduced in Section 3.10. 2.8.2 Absolute units For the functions in circlize package, they needs arguments which are lengths measured either in the canvas coordinate or in the data coordinate. E.g. track.height argument in circos.track() corresponds to percent of radius of the unit circle. circlize package is built in the R base graphic system which is not straightforward to define a length with absolute units (e.g. a line of length 2 cm). To solve this problem, circlize provides several functions which convert absolute units to the canvas coordinate or the data coordinate accordingly. mm_h(), cm_h(), inches_h()/inch_h() functions convert absolute units to the canvas coordinate in the radical direction, which normally define the heights of e.g. tracks. If users want to convert a string height or width to the canvas coordinate, directly use strheight() or strwidth() functions. mm_h(2) # 2mm cm_h(1) # 1cm mm_x(), cm_x(), inches_x()/inch_x(), mm_y(), cm_y(), inches_y()/inch_y() convert absolute units to the data coordinate in the x or y direction. By default, the conversion is applied in the “current” cell, but it can still be used in other cells by specifying sector.index and track.index arguments. mm_x(2) mm_x(1, sector.index, track.index) mm_y(2) mm_y(1, sector.index, track.index) Since the width of the cell is not identical from the top to the bottom in the cell, for *_x() function, the position on y direction where the convert is applied can be specified by the h argument (measured in data coordinate). By default it is converted at the middle point on y-axis. mm_x(2, h) Normally the difference of e.g. mm_x(2) at different y positions in a track is very small (unless the track has very big track.height), so in most cases, you can ignore the setting of h argument. Following plot (Figure 2.9) is an example of setting absolute units. sectors = letters[1:10] circos.par(cell.padding = c(0, 0, 0, 0), track.margin = c(0, 0)) circos.initialize(sectors, xlim = cbind(rep(0, 10), runif(10, 0.5, 1.5))) circos.track(ylim = c(0, 1), track.height = mm_h(5), panel.fun = function(x, y) { circos.lines(c(0, 0 + mm_x(5)), c(0.5, 0.5), col = &quot;blue&quot;) }) circos.track(ylim = c(0, 1), track.height = cm_h(1), track.margin = c(0, mm_h(2)), panel.fun = function(x, y) { xcenter = get.cell.meta.data(&quot;xcenter&quot;) circos.lines(c(xcenter, xcenter), c(0, cm_y(1)), col = &quot;red&quot;) }) circos.track(ylim = c(0, 1), track.height = inch_h(1), track.margin = c(0, mm_h(5)), panel.fun = function(x, y) { line_length_on_x = cm_x(1*sqrt(2)/2) line_length_on_y = cm_y(1*sqrt(2)/2) circos.lines(c(0, line_length_on_x), c(0, line_length_on_y), col = &quot;orange&quot;) }) Figure 2.9: Setting absolute units circos.clear() 2.8.3 circos.info() and circos.clear() You can get basic information of your current circular plot by circos.info(). The function can be called at any time. sectors = letters[1:3] circos.initialize(sectors, xlim = c(1, 2)) circos.info() ## All your sectors: ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## No track has been created ## ## Your current sector.index is a circos.track(ylim = c(0, 1)) circos.info(sector.index = &quot;a&quot;, track.index = 1) ## sector index: &#39;a&#39; ## track index: 1 ## xlim: [1, 2] ## ylim: [0, 1] ## cell.xlim: [0.991453, 2.008547] ## cell.ylim: [-0.1, 1.1] ## xplot (degree): [0, 241] ## yplot (radius): [0.79, 0.99] ## cell.width (degree): 119 ## cell.height (radius): 0.2 ## track.margin: c(0.01, 0.01) ## cell.padding: c(0.02, 1, 0.02, 1) ## ## Your current sector.index is c ## Your current track.index is 1 circos.clear() It can also add labels to all cells by circos.info(plot = TRUE). You should always call circos.clear() at the end of every circular plot. There are several parameters for circular plot which can only be set before circos.initialize(), thus, before you draw the next circular plot, you need to reset all these parameters. 2.9 Set gaps between tracks In the older versions, you need to set track.height parameter either in circos.par() or in circos.track() to control the space between tracks. Now there is a new set_track_gap() function which simplifies the setting of gaps between two tracks. With the mm_h()/cm_h()/inch_h() functions, it is very easy to set the gaps with physical units (Figure 2.10). circos.initialize(letters[1:10], xlim = c(0, 1)) circos.track(ylim = c(0, 1)) set_track_gap(mm_h(2)) # 2mm circos.track(ylim = c(0, 1)) set_track_gap(cm_h(0.5)) # 0.5cm circos.track(ylim = c(0, 1)) Figure 2.10: Setting gaps between tracks. circos.clear() "],["graphics.html", "Chapter 3 Graphics 3.1 Setting colors 3.2 Points 3.3 Lines 3.4 Segments 3.5 Text 3.6 Rectangles and polygons 3.7 Axes 3.8 Barplots, boxplots and violin plots 3.9 Circular arrows 3.10 Raster image 3.11 Links 3.12 Highlight sectors and tracks 3.13 Work together with the base graphic system", " Chapter 3 Graphics In this chapter, we will introduce low-level functions that add graphics to the circle. Usages of most of these functions are similar as normal graphic functions (e.g. points(), lines()). Combination use of these functions can generate very complex circular plots. All low-level functions accept sector.index and track.index arguments which indicate which cell the graphics are added in. By default the graphics are added in the “current” sector and “current” track, so it is recommended to use them directly inside panel.fun function. However, they can also be used in other places with explicitly specifying sector and track index. Following code shows an example of using ciros.points(). circos.track(..., panel.fun = function(x, y) { circos.points(x, y) }) circos.points(x, y, sector.index, track.index) In this chapter, we will also discuss how to customize links and how to highlight regions in the circle. 3.1 Setting colors Color is a major aesthetic element to map to the data points. In circlize there are two functions that provides customization of colors. colorRamp2() provides an exact way for mapping continuous values. users specify a vector of break values and a vector of colors, all the other colors are linearly interpolated between the correspoding break values. In following example, we generate a color mapping which is symmetric to zero. col_fun = colorRamp2(c(-2, 0, 2), c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;)) col_fun(seq(-5, 1, by = 1)) # all the values smaller than -2 are all mapped to blue ## [1] &quot;#0000FFFF&quot; &quot;#0000FFFF&quot; &quot;#0000FFFF&quot; &quot;#0000FFFF&quot; &quot;#B38BFFFF&quot; &quot;#FFFFFFFF&quot; ## [7] &quot;#FF9E81FF&quot; rand_color() implements the algorithem of randomColor.js. See the following example: par(mar = c(1, 1, 1, 1)) plot(NULL, xlim = c(1, 10), ylim = c(1, 8), axes = FALSE, ann = FALSE) points(1:10, rep(1, 10), pch = 16, cex = 5, col = rand_color(10, luminosity = &quot;random&quot;)) points(1:10, rep(2, 10), pch = 16, cex = 5, col = rand_color(10, luminosity = &quot;bright&quot;)) points(1:10, rep(3, 10), pch = 16, cex = 5, col = rand_color(10, luminosity = &quot;light&quot;)) points(1:10, rep(4, 10), pch = 16, cex = 5, col = rand_color(10, luminosity = &quot;dark&quot;)) points(1:10, rep(5, 10), pch = 16, cex = 5, col = rand_color(10, hue = &quot;red&quot;, luminosity = &quot;bright&quot;)) points(1:10, rep(6, 10), pch = 16, cex = 5, col = rand_color(10, hue = &quot;green&quot;, luminosity = &quot;bright&quot;)) points(1:10, rep(7, 10), pch = 16, cex = 5, col = rand_color(10, hue = &quot;blue&quot;, luminosity = &quot;bright&quot;)) points(1:10, rep(8, 10), pch = 16, cex = 5, col = rand_color(10, hue = &quot;monochrome&quot;, luminosity = &quot;bright&quot;)) Actually there is another function col2value() which can convert back to the values highly approximate to the original values from a vector of colors. col_fun = colorRamp2(c(-2, 0, 2), c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;)) value = seq(-2, 2, by = 0.2) value ## [1] -2.0 -1.8 -1.6 -1.4 -1.2 -1.0 -0.8 -0.6 -0.4 -0.2 0.0 0.2 0.4 0.6 0.8 ## [16] 1.0 1.2 1.4 1.6 1.8 2.0 col = col_fun(value) col2value(col, col_fun = col_fun) ## [1] -2.000000e+00 -1.795620e+00 -1.595206e+00 -1.391406e+00 -1.189672e+00 ## [6] -9.870220e-01 -7.853407e-01 -5.861849e-01 -3.901391e-01 -1.985154e-01 ## [11] -7.401487e-17 1.761338e-01 3.592285e-01 5.454043e-01 7.429882e-01 ## [16] 9.423823e-01 1.150753e+00 1.359655e+00 1.575352e+00 1.785834e+00 ## [21] 2.000000e+00 3.2 Points Adding points by circos.points() is similar as points() function. Possible usages are: circos.points(x, y) circos.points(x, y, sector.index, track.index) circos.points(x, y, pch, col, cex) There is a companion function circos.trackPoints() which adds points to all sectors in a same track simultaneously. The input of circos.trackPoints() must contain a vector of categorical factors, a vector of x values and a vector of y values. X values and y values are split by the categorical variable and corresponding subset of x and y values are internally sent to circos.points(). circos.trackPoints() adds points to the “current” track by default which is the most recently created track. Other tracks can also be selected by explictly setting track.index argument. circos.track(...) circos.trackPoints(sectors, x, y) circos.trackPoints() is simply implemented by circos.points() with a for loop. However, it is more recommended to directly use circos.points() and panel.fun which provides great more flexibility. Actually following code is identical to above code. circos.track(sectors, x, y, panel.fun = function(x, y) { circos.points(x, y) }) Other low-level functions also have their companion circos.track*() function. The usage is same as circos.trackPoints() and they will not be further discussed in following sections. 3.3 Lines Adding lines by circos.lines() is similar as lines() function. One additional feature is that the areas under or above the lines can be filled by specifing area argument to TRUE. Position of the baseline can be set to a pre-defined string of bottom or top, or a numeric value which is the position on y-axis. When area is set to TRUE, col controls the filled color and border controls the color for the borders. baseline argument is also workable when lty is set to \"h\". Note when lty is set to \"h\", graphic parameters such as col can be set as a vector with same length as x. Figure 3.1 illustrates supported lty settings and area/baseline settings. Figure 3.1: Line styles and areas supported in circos.lines() Straight lines are transformed to curves when mapping to the circular layout (Figure 3.2). Normally, curves are approximated by a series of segments of straight lines. With more and shorter segments, there is better approximation, but with larger size if the figures are generated into e.g. PDF files, especially for huge dataset. Default length of segments in circlize is a balance between the quality and size of the figure. You can set the length of the unit segment by unit.circle.segments option in circos.par(). The length of the segment is calculated as the length of the unit circle (2\\(\\pi\\)) divided by unit.circle.segments. In some scenarios, actually you don’t need to segment the lines such as radical lines, then you can set straight argument to TRUE to get rid of unnecessary segmentations. Figure 3.2: Transformation of straight lines into curves in the circle. Possible usages for circos.lines() are: circos.lines(x, y) circos.lines(x, y, sector.index, track.index) circos.lines(x, y, col, lwd, lty, type, straight) circos.lines(x, y, col, area, baseline, border) 3.4 Segments Line segments can be added by circos.segments() function. The usage is similar as segments(). Radical segments can be added by setting straight to TRUE. An example is in Figure 3.3. circos.segments(x0, y0, x1, y1) circos.segments(x0, y0, x1, y1, straight) circos.initialize(letters[1:8], xlim = c(0, 1)) circos.track(ylim = c(0, 1), track.height = 0.3, panel.fun = function(x, y) { x = seq(0.2, 0.8, by = 0.2) y = seq(0.2, 0.8, by = 0.2) circos.segments(x, 0.1, x, 0.9) circos.segments(0.1, y, 0.9, y) }) Figure 3.3: Draw segments. circos.clear() 3.5 Text Adding text by circos.text() is similar as text() function. Text is added on the plot for human reading, thus, when putting the text on the circle, the facing of text is very important. circos.text() supports seven facing options which are inside, outside, clockwise, reverse.clockwise, downward, bending.inside and bending.outside. Please note for bending.inside and bending.outside, currently, single line text is only supported. If you want to put bended text into two lines, you need to split text into two lines and add each line by circos.text() separately. The different facings are illustrated in Figure 3.4. Figure 3.4: Text facings. Possible usages for circos.text() are: circos.text(x, y, labels) circos.text(x, y, labels, sector.index, track.index) circos.text(x, y, labels, facing, niceFacing, adj, cex, col, font) If, e.g., facing is set to inside, text which is on the bottom half of the circle is still facing to the top and hard to read. To make text more easy to read and not to hurt readers’ neck too much, circos.text() provides niceFacing option which automatically adjust text facing according to their positions in the circle. niceFacing only works for facing value of inside, outside, clockwise, reverse.clockwise, bending.inside and bending.outside. When niceFacing is on, adj is also adjusted according to the corresponding facings. Figure 3.5 illustrates text positions under different settings of adj and facing. The red dots are the positions of the texts. Figure 3.5: Human easy text facing. adj is internally passed to text(), thus, it actually adjusts text positions either horizontally or vertically (in the canvas coordinate). If the direction of the offset is circular, the offset value can be set as degrees that the position of the text is adjusted by wrapping the offset by degree(). circos.text(x, y, labels, adj = c(0, degree(5)), facing = &quot;clockwise&quot;) As circos.text() is applied in the data coordiante, offset can be directly added to x or/and y as a value measured in the data coordinate. An absolute offset can be set by using e.g. mm_x() (in x direction) and mm_y() (in y direction). circos.text(x + mm_x(2), y + mm_y(2), labels) 3.6 Rectangles and polygons Theoretically, circular rectangles and polygons are all polygons. If you imagine the plotting region in a cell as Cartesian coordinate, then circos.rect() draws rectangles. In the circle, the up and bottom edge become two arcs. Note this function can be vectorized. circos.rect(xleft, ybottom, xright, ytop) circos.rect(xleft, ybottom, xright, ytop, sector.index, track.index) circos.rect(xleft, ybottom, xright, ytop, col, border, lty, lwd) circos.polygon() draws a polygon through a series of points in a cell. Please note the first data point must overlap to the last data point. circos.polygon(x, y) circos.polygon(x, y, col, border, lty, lwd) In Figure 3.6, the area of standard deviation of the smoothed line is drawn by circos.polygon(). Source code can be found in the Examples section of the circos.polygon() help page. Figure 3.6: Area of standard deviation of the smoothed line. 3.7 Axes Mostly, we only draw x-axes on the circle. circos.axis() or circos.xaxis() privides options to customize x-axes which are on the circular direction. It supports basic functionalities as axis() such as defining the breaks and corresponding labels. Besides that, the function also supports to put x-axes to a specified position on y direction, to position the x-axes facing the center of the circle or outside of the circle, and to customize the axes ticks. The at and labels arguments can be set to a long vector that the parts which exceed the maximal value in the corresponding cell are removed automatically. The facing of labels text can be optimized by labels.niceFacing (by default it is TRUE). Figure 3.7 illustrates different settings of x-axes. The explanations are as follows: a: Major ticks are calculated automatically, other settings are defaults. b: Ticks are pointing to inside of the circle, facing of tick labels is set to outside. c: Position of x-axis is bottom in the cell. d: Ticks are pointing to the inside of the circle, facing of tick labels is set to reverse.clockwise. e: manually set major ticks and also set the position of x-axis. f: replace numeric labels to characters, with no minor ticks. g: No ticks for both major and minor, facing of tick labels is set to reverse.clockwise. h: Number of minor ticks between two major ticks is set to 2. Length of ticks is longer. Facing of tick labels is set to clockwise. Figure 3.7: X-axes As you may notice in the above figure, when the first and last axis labels exceed data ranges on x-axis in the corresponding cell, their positions are automatically adjusted to be shifted inwards in the cell. Possible usage of circos.axis() is as follows. Note h can be bottom, top or a numeric value, and major.tick.length can be set with mm_y()/cm_y()/inch_y(). circos.axis(h) circos.axis(h, sector.index, track.index) circos.axis(h, major.at, labels, major.tick, direction) circos.axis(h, major.at, labels, major.tick, labels.font, labels.cex, labels.facing, labels.niceFacing) circos.axis(h, major.at, labels, major.tick, minor.ticks, major.tick.length, lwd) Y-axis is also supported by circos.yaxis(). The usage is similar as circos.axis() One thing that needs to be note is users need to manually adjust gap.degree/gap.after in circos.par() to make sure there are enough spaces for y-axes. (Figure 3.8) circos.yaxis(side) # break values are automatically calculated circos.yaxis(side, at, labels, sector.index, track.index) Figure 3.8: Y-axes 3.8 Barplots, boxplots and violin plots circos.barplot(), circos.boxplot() and circos.violin() are introduced together because the values on x-axes are the integer indices of bars, boxes or violins for which xlim should be properly set in circos.initialize(). For circular barplots, users can either specify a vector which generates a “normal” barplot, or a matrix which generates a stacked barplot (Figure 3.9). par(mfrow = c(1, 2)) circos.initialize(letters[1:4], xlim = c(0, 10)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { value = runif(10) circos.barplot(value, 1:10 - 0.5, col = 1:10) }) circos.track(ylim = c(-1, 1), panel.fun = function(x, y) { value = runif(10, min = -1, max = 1) circos.barplot(value, 1:10 - 0.5, col = ifelse(value &gt; 0, 2, 3)) }) circos.clear() circos.initialize(letters[1:4], xlim = c(0, 10)) circos.track(ylim = c(0, 4), panel.fun = function(x, y) { value = matrix(runif(10*4), ncol = 4) circos.barplot(value, 1:10 - 0.5, col = 2:5) }) Figure 3.9: Circular barplots. circos.clear() For circular boxplots, the boxes can be drawn one-by-one by providing a vector for each box, or drawn in batch with a list/matrix as input (Figure 3.10). par(mfrow = c(1, 2)) circos.initialize(letters[1:4], xlim = c(0, 10)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { for(pos in seq(0.5, 9.5, by = 1)) { value = runif(10) circos.boxplot(value, pos) } }) circos.clear() circos.initialize(letters[1:4], xlim = c(0, 10)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { value = replicate(runif(10), n = 10, simplify = FALSE) circos.boxplot(value, 1:10 - 0.5, col = 1:10) }) Figure 3.10: Circular boxplots. circos.clear() For circular violin plots, the violins can be drawn one-by-one by providing a vector for each violin, or drawn in batch with a list/matrix as input (Figure 3.11). Please note, to make it comparable between violins, max_density argument should be set. par(mfrow = c(1, 2)) circos.initialize(letters[1:4], xlim = c(0, 10)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { for(pos in seq(0.5, 9.5, by = 1)) { value = runif(10) circos.violin(value, pos) } }) circos.clear() circos.initialize(letters[1:4], xlim = c(0, 10)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { value = replicate(runif(10), n = 10, simplify = FALSE) circos.violin(value, 1:10 - 0.5, col = 1:10) }) Figure 3.11: Circular violin plots. circos.clear() 3.9 Circular arrows circos.arrow() draws circular arrows parallel to the circle. Since the arrow is always parallel to the circle, on x-direction, the start and end position of the arrow need to be defined while on the y-direction, only the position of the center of arrow needs to be defined. Also width controls the width of the arrow and the length is defined by x2 - x1. arrow.head.width and arrow.head.length control the size of the arrow head, and values are measured in the data coordinate in corresponding cell. tail controls the shape of the arrow tail. Note for width, arrow.head.width and arrow.head.length, the value can be set by e.g. mm_x(), mm_y() with absolute units. If users want to draw the arrows in the reversed direction, set arrow.position argument to start. See Figure 3.12. par(mfrow = c(1, 2)) circos.initialize(letters[1:4], xlim = c(0, 1)) col = rand_color(4) tail = c(&quot;point&quot;, &quot;normal&quot;, &quot;point&quot;, &quot;normal&quot;) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.arrow(x1 = 0, x2 = 1, y = 0.5, width = 0.4, arrow.head.width = 0.6, arrow.head.length = cm_x(1), col = col[CELL_META$sector.numeric.index], tail = tail[CELL_META$sector.numeric.index]) }, bg.border = NA, track.height = 0.4) circos.clear() circos.initialize(letters[1:4], xlim = c(0, 1)) tail = c(&quot;point&quot;, &quot;normal&quot;, &quot;point&quot;, &quot;normal&quot;) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.arrow(x1 = 0, x2 = 1, y = 0.5, width = 0.4, arrow.head.width = 0.6, arrow.head.length = cm_x(1), col = col[CELL_META$sector.numeric.index], tail = tail[CELL_META$sector.numeric.index], arrow.position = &quot;start&quot;) }, bg.border = NA, track.height = 0.4) Figure 3.12: Circular arrows. circos.clear() Circular arrows are useful to visualize events which happen in circular style, such as different phases in cell cycle. Following example code visualizes four phases in cell cycle where the width of sectors correspond to the hours in each phase (Figure 3.13). Also circular arrows can be used to visualize genes in circular genome where the arrows represent the orientation of the gene, such as mitochondrial genome or plasmid genome. Just remember if the gene is in the reverse strand or the negative strand, set arrow.position = \"start\" to draw the arrow in the other direction. cell_cycle = data.frame(phase = factor(c(&quot;G1&quot;, &quot;S&quot;, &quot;G2&quot;, &quot;M&quot;), levels = c(&quot;G1&quot;, &quot;S&quot;, &quot;G2&quot;, &quot;M&quot;)), hour = c(11, 8, 4, 1)) color = c(&quot;#66C2A5&quot;, &quot;#FC8D62&quot;, &quot;#8DA0CB&quot;, &quot;#E78AC3&quot;) circos.par(start.degree = 90) circos.initialize(cell_cycle$phase, xlim = cbind(rep(0, 4), cell_cycle$hour)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.arrow(CELL_META$xlim[1], CELL_META$xlim[2], arrow.head.width = CELL_META$yrange*0.8, arrow.head.length = cm_x(0.5), col = color[CELL_META$sector.numeric.index]) circos.text(CELL_META$xcenter, CELL_META$ycenter, CELL_META$sector.index, facing = &quot;downward&quot;) circos.axis(h = 1, major.at = seq(0, round(CELL_META$xlim[2])), minor.ticks = 1, labels.cex = 0.6) }, bg.border = NA, track.height = 0.3) Figure 3.13: Cell cycle. circos.clear() 3.10 Raster image circos.raster() is used to add a raster image at a certain position in the circle with proper rotation. The first input variable should be a raster object or an object that can be converted by as.raster(). Facing of the image is controlled by facing and niceFacing arguments which are similar as in circos.text(). When value of facing is one of inside, outside, reverse.clockwise, clockwise and downward, the size of raster image should have absolute values which should be specified in the form of number- unit such as \"20mm\", \"1.2cm\" or \"0.5inche\". If only one of width and height is specified, the other one is automatically calculated by using the aspect ratio of the original image. Following example shows five types of facings of the raster image (figure 3.14). library(png) image = system.file(&quot;extdata&quot;, &quot;Rlogo.png&quot;, package = &quot;circlize&quot;) image = as.raster(readPNG(image)) circos.par(start.degree = 90) circos.initialize(letters[1:5], xlim = c(0, 1)) all_facing_options = c(&quot;inside&quot;, &quot;outside&quot;, &quot;reverse.clockwise&quot;, &quot;clockwise&quot;, &quot;downward&quot;) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.raster(image, CELL_META$xcenter, CELL_META$ycenter, width = &quot;1cm&quot;, facing = all_facing_options[CELL_META$sector.numeric.index]) circos.text(CELL_META$xcenter, CELL_META$ycenter, all_facing_options[CELL_META$sector.numeric.index], facing = &quot;inside&quot;, niceFacing = TRUE) }) Figure 3.14: Five facings of raster image. circos.clear() Also facing can be set to bending.inside and bending.outside that the image is filled to a circular rectangle. The strategy is to plot each original pixel as a small circular rectangle by circos.rect(), thus, the plotting is quite slow. If the original image is too huge, scaling argument can be set to reduce the size of the original image. Following code draws the image of the cover of this book which is a circular style of Keith Haring’s doodle (Figure 3.15). The original source of the plot is from http://www.thegreenhead.com/imgs/keith-haring-double-retrospect-worlds-largest-jigsaw-puzzle-2.jpg. load(system.file(&quot;extdata&quot;, &quot;doodle.RData&quot;, package = &quot;circlize&quot;)) circos.par(&quot;cell.padding&quot; = c(0, 0, 0, 0)) circos.initialize(letters[1:16], xlim = c(0, 1)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { img = img_list[[CELL_META$sector.numeric.index]] circos.raster(img, CELL_META$xcenter, CELL_META$ycenter, width = CELL_META$xrange, height = CELL_META$yrange, facing = &quot;bending.inside&quot;) }, track.height = 0.25, bg.border = NA) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { img = img_list[[CELL_META$sector.numeric.index + 16]] circos.raster(img, CELL_META$xcenter, CELL_META$ycenter, width = CELL_META$xrange, height = CELL_META$yrange, facing = &quot;bending.inside&quot;) }, track.height = 0.25, bg.border = NA) circos.clear() Figure 3.15: Fill raster image to the cell. 3.11 Links Links or ribbons are important part for the circular visualization. They are used to represent relations or interactions between sectors. In circlize, circos.link() draws links between single points and intervals. There are four mandatory arguments which are index for the first sector, positions on the first sector, index for the second sector and positions on the second sector. If the positions on the two sectors are all single points, the link represents as a line. If the positions on the two sectors are intervals, the link represents as a robbon (Figure 3.16). Possible usage for circos.link() is as follows. circos.link(sector.index1, 0, sector.index2, 0) circos.link(sector.index1, c(0, 1), sector.index2, 0) circos.link(sector.index1, c(0, 1), sector.index2, c(1, 2)) circos.link(sector.index1, c(0, 1), sector.index2, 0, col, lwd, lty, border) Figure 3.16: Different types of links. The position of link end is controlled by rou (sorry the name should be called rho, sorry for my Chinese Greek accent). By default, it is the bottom of the most inside track and normally, you don’t need to care about this setting. The two ends of the link are located in a same circle by default. The positions of two ends can be adjusted with different values for rou1 and rou2 arguments. See Figure 3.17. circos.link(sector.index1, 0, sector.index2, 0, rou) circos.link(sector.index1, 0, sector.index2, 0, rou1, rou2) Figure 3.17: Positions of link ends. The height of the link is controlled by h argument. In most cases, you don’t need to care about the value of h because they are internally calculated based on the width of each link. However, when the link represents as a ribbon (i.e. link from point to interval or from interval to interval), It can not always ensure that one border is always below or above the other, which means, in some extreme cases, the two borders are intersected and the link would be messed up. It happens especially when position of the two ends are too close or the width of one end is extremely large while the width of the other end is too small. In that case, users can manually set height of the top and bottom border by h and h2 (Figure 3.18). circos.link(sector.index1, 0, sector.index2, 0, h) circos.link(sector.index1, 0, sector.index2, 0, h, h2) Figure 3.18: Adjust link heights. When there are many links, the height of all links can be systematically adjusted by h.ratio (Figure 3.19). The value is between 0 and 1. Figure 3.19: Adjust link heights by ‘h.ratio’. The border of link (if it is a ribbon) or the link itself (if it is a line) is in fact a quadratic Bezier curve, thus you can control the shape of the link by w and w2 (w2 controls the shape of bottom border). See Figure 3.20 for examples. For more explanation of w, please refer to http://en.wikipedia.org/wiki/B%C3%A9zier_curve#Rational_B.C3.A9zier_curves. circos.link(sector.index1, 0, sector.index2, 0, w) circos.link(sector.index1, 0, sector.index2, 0, w, w2) Figure 3.20: Different link shapes. When the links represent as ribbons and the two ends overlap, the links will be de-generated as a ‘hill’ (Figure 3.21). Figure 3.21: Link as a hill. Links can have arrows to represent the directions. The directional argument controls how to add arrows. A value of 0 means there is no direction, 1 means the direction is from end 1 to end 2, -1 means the direction is from end 2 to end 1, and 2 means bi-direction. If the link represents as a ribbon, a line with arrow will be added in the center of the link to represent directions. See Figure 3.22. Type of arrows is controlled by arr.type argument and it is actually passed to Arrowhead() defined in shape package. Besides the arrow types supported in shape package, there is an additional arrow type big.arrow which turns the robbon into a big arrow (Figure 3.22). Unequal height of the link ends can also represent directions which we will discuss more with the chordDiagram() function. circos.link(sector.index1, 0, sector.index2, 0, directional = 1) circos.link(sector.index1, c(0, 1), sector.index2, c(0, 1), directional = -1) Figure 3.22: Link with arrows. 3.12 Highlight sectors and tracks draw.sector() draws sectors, rings or their parts. This function is useful if you want to highlight some parts of your circular plot. it needs arguments of the position of circle center (by default c(0, 0)), the start degree and the end degree for sectors, and radius for two edges (or one edge) which are up or bottom borders. draw.sector() is independent from the circular plot. Possible usage of draw.sector() is as follows. draw.sector(start.degree, end.degree, rou1) draw.sector(start.degree, end.degree, rou1, rou2, center) draw.sector(start.degree, end.degree, rou1, rou2, center, col, border, lwd, lty) Directions from start.degree and end.degree is important for drawing sectors. By default, it is clock wise. draw.sector(start.degree, end.degree, clock.wise = FALSE) Following code shows examples of draw.sector() (Figure 3.23). par(mar = c(1, 1, 1, 1)) plot(c(-1, 1), c(-1, 1), type = &quot;n&quot;, axes = FALSE, ann = FALSE, asp = 1) draw.sector(20, 0) draw.sector(30, 60, rou1 = 0.8, rou2 = 0.5, clock.wise = FALSE, col = &quot;#FF000080&quot;) draw.sector(350, 1000, col = &quot;#00FF0080&quot;, border = NA) draw.sector(0, 180, rou1 = 0.25, center = c(-0.5, 0.5), border = 2, lwd = 2, lty = 2) draw.sector(0, 360, rou1 = 0.7, rou2 = 0.6, col = &quot;#0000FF80&quot;) Figure 3.23: General usage of ‘draw.sector()’. In order to highlight cells in the circular plot, we can use get.cell.meta.data() to get the information of positions of cells. E.g. the start degree and end degree can be obtained through cell.start.degree and cell.end.degree, and the position of the top border and bottom border can be obtained through cell.top.radius and cell.bottom.radius. Following code shows several examples to highlight sectors and tracks. First we create a circular plot with eight sectors and three tracks. sectors = letters[1:8] circos.initialize(sectors, xlim = c(0, 1)) for(i in 1:3) { circos.track(ylim = c(0, 1)) } circos.info(plot = TRUE) If we want to highlight sector a (Figure 3.24): draw.sector(get.cell.meta.data(&quot;cell.start.degree&quot;, sector.index = &quot;a&quot;), get.cell.meta.data(&quot;cell.end.degree&quot;, sector.index = &quot;a&quot;), rou1 = get.cell.meta.data(&quot;cell.top.radius&quot;, track.index = 1), col = &quot;#FF000040&quot;) If we want to highlight track 1 (Figure 3.24): draw.sector(0, 360, rou1 = get.cell.meta.data(&quot;cell.top.radius&quot;, track.index = 1), rou2 = get.cell.meta.data(&quot;cell.bottom.radius&quot;, track.index = 1), col = &quot;#00FF0040&quot;) If we want to highlight track 2 and 3 in sector e and f (Figure 3.24): draw.sector(get.cell.meta.data(&quot;cell.start.degree&quot;, sector.index = &quot;e&quot;), get.cell.meta.data(&quot;cell.end.degree&quot;, sector.index = &quot;f&quot;), rou1 = get.cell.meta.data(&quot;cell.top.radius&quot;, track.index = 2), rou2 = get.cell.meta.data(&quot;cell.bottom.radius&quot;, track.index = 3), col = &quot;#0000FF40&quot;) If we want to highlight specific regions such as a small region inside cell h:2, we can use circlize() to calculate the positions in the polar coordinate. But always keep in mind that x-axis in the cell are always clock wise. See Figure 3.24. pos = circlize(c(0.2, 0.8), c(0.2, 0.8), sector.index = &quot;h&quot;, track.index = 2) draw.sector(pos[1, &quot;theta&quot;], pos[2, &quot;theta&quot;], pos[1, &quot;rou&quot;], pos[2, &quot;rou&quot;], clock.wise = TRUE, col = &quot;#00FFFF40&quot;) circos.clear() Figure 3.24: Highlight sectors and tracks. If the purpose is to simply highlight complete cells, there is a helper function highlight.sector() for which you only need to specify index for sectors and tracks that you want to to highlight. Paddings of the highligted regions can be set by padding argument which should contain four values representing ratios of the width or height of the highlighted region (Figure 3.25). One advantage of highlight.sector() is that it supports to add text in the highlighted regions. By default, the text is drawn at that center of the highlighted region. The position on the radical direction can be set by text.vjust argument either by a numeric value or a string in form of \"2 inches\" or \"-1.2cm\". sectors = letters[1:8] circos.initialize(sectors, xlim = c(0, 1)) for(i in 1:4) { circos.track(ylim = c(0, 1)) } circos.info(plot = TRUE) highlight.sector(c(&quot;a&quot;, &quot;h&quot;), track.index = 1, text = &quot;a and h belong to a same group&quot;, facing = &quot;bending.inside&quot;, niceFacing = TRUE, text.vjust = &quot;6mm&quot;, cex = 0.8) highlight.sector(&quot;c&quot;, col = &quot;#00FF0040&quot;) highlight.sector(&quot;d&quot;, col = NA, border = &quot;red&quot;, lwd = 2) highlight.sector(&quot;e&quot;, col = &quot;#0000FF40&quot;, track.index = c(2, 3)) highlight.sector(c(&quot;f&quot;, &quot;g&quot;), col = NA, border = &quot;green&quot;, lwd = 2, track.index = c(2, 3), padding = c(0.1, 0.1, 0.1, 0.1)) highlight.sector(sectors, col = &quot;#FFFF0040&quot;, track.index = 4) Figure 3.25: Highlight sectors. circos.clear() 3.13 Work together with the base graphic system circlize is built on the base R graphic system, then, of course the base graphic functions can be used in combination with circlize functions. On the other hand, circlize() converts data points from the data coordinates to the canvas coordinates where the base graphic function can be directly applied. Normally, the base functions such as title(), text(), legend() can be used to add extra information on the plot (Figure 3.26). Sometimes, when the text or other graphics are far from the circle, you may set par(xpd = NA) so that the plotting is not clipped. sectors = letters[1:4] circos.initialize(sectors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.points(1:20/20, 1:20/20) }) text(0, 0, &quot;This is\\nthe center&quot;, cex = 1.5) legend(&quot;bottomleft&quot;, pch = 1, legend = &quot;This is the legend&quot;) title(&quot;This is the title&quot;) Figure 3.26: Work with base graphic functions. circos.clear() "],["legends.html", "Chapter 4 Legends", " Chapter 4 Legends circlize provides complete freedom for users to design their own graphics by implementing the self-defined function panel.fun. However one drawback arises that circlize is completely blind to users’ data so that one important thing is missing for the visualization which is the legend. Although legends cannot be automatically generated by circlize, by using functionality from other R packages, it is just a few more lines to really implement it. Here I will demonstrate how to customize legends and arrange to the circular plot. As an example, a circular plot which contains two tracks and links inside the circle is generated. The first track will have a legend that contains points, the second track will have a legend that contains lines, and the links correspond to a continuous color mapping. The code is wrapped into a function so that it can be used repeatedly. library(circlize) col_fun = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;yellow&quot;, &quot;red&quot;)) circlize_plot = function() { set.seed(12345) sectors = letters[1:10] circos.initialize(sectors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.points(runif(20), runif(20), cex = 0.5, pch = 16, col = 2) circos.points(runif(20), runif(20), cex = 0.5, pch = 16, col = 3) }) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.lines(sort(runif(20)), runif(20), col = 4) circos.lines(sort(runif(20)), runif(20), col = 5) }) for(i in 1:10) { circos.link(sample(sectors, 1), sort(runif(10))[1:2], sample(sectors, 1), sort(runif(10))[1:2], col = add_transparency(col_fun(rnorm(1)))) } circos.clear() } In ComplexHeatmap package with version higher than 1.99.0, there is a Legend() function which customizes legends with various styles. In following code, legends for the two tracks and links are constructed. In the end the three legends are packed vertically by packLegend(). For more detailed usage of Legend() and packLegend(), please refer to their help pages and the ComplexHeatmap book. library(ComplexHeatmap) # discrete lgd_points = Legend(at = c(&quot;label1&quot;, &quot;label2&quot;), type = &quot;points&quot;, legend_gp = gpar(col = 2:3), title_position = &quot;topleft&quot;, title = &quot;Track1&quot;) # discrete lgd_lines = Legend(at = c(&quot;label3&quot;, &quot;label4&quot;), type = &quot;lines&quot;, legend_gp = gpar(col = 4:5, lwd = 2), title_position = &quot;topleft&quot;, title = &quot;Track2&quot;) # continuous lgd_links = Legend(at = c(-2, -1, 0, 1, 2), col_fun = col_fun, title_position = &quot;topleft&quot;, title = &quot;Links&quot;) lgd_list_vertical = packLegend(lgd_points, lgd_lines, lgd_links) lgd_list_vertical ## A pack of 3 legends lgd_points, lgd_lines, lgd_links and lgd_list_vertical can be thought as boxes which contain all graphical elements for legends and they can be added to the plot by draw(). circlize is implemented in the base graphic system while ComplexHeatmap is implemented by grid graphic system. However, these two systems can be mixed somehow. We can directly add grid graphics to the base graphics. (Actually they are two independent layers but drawn on a same graphic device.) circlize_plot() # next the grid graphics are added directly to the plot # where circlize has created. draw(lgd_list_vertical, x = unit(4, &quot;mm&quot;), y = unit(4, &quot;mm&quot;), just = c(&quot;left&quot;, &quot;bottom&quot;)) Figure 4.1: Directly add grid graphics. In Figure 4.1, the whole image region corresponds to the circular plot and the legend layer is drawn just on top of it. Actually you can see that one big problem is when there are many legends that the size for the legends is too big, they may overap to the circle. One solution is to split the legends into several parts and add each part to different corners in the plot (Figure 4.2). lgd_list_vertical2 = packLegend(lgd_points, lgd_lines) circlize_plot() # next the grid graphics are added directly to the plot # where circlize has created. draw(lgd_list_vertical2, x = unit(4, &quot;mm&quot;), y = unit(4, &quot;mm&quot;), just = c(&quot;left&quot;, &quot;bottom&quot;)) draw(lgd_links, x = unit(1, &quot;npc&quot;) - unit(2, &quot;mm&quot;), y = unit(4, &quot;mm&quot;), just = c(&quot;right&quot;, &quot;bottom&quot;)) Figure 4.2: Split into two legends. Still it can not solve the problem and sometimes it even makes the plot so messed up. One better way is to split the image region into two parts where one part only for the circular plot and the other part for legends. To mix grid graphics and base graphics, ther are two important packages to use: the grid package and gridBase package. grid is the base for making grid graphics as well as arranging plotting regions (or, viewports in grid term), and gridBase makes it easy to integrate base graphics into grid system. Following code is straightforward to understand. Only one line needs to be noticed: par(omi = gridOMI(), new = TRUE) that gridOMI() calculates the outer margins for the base graphics so that the base graphics can be put at the correct place and new = TRUE to ensure the base graphics are added to current graphic device instead of opening a new one. Here I use plot.new() to open a new graphic device. In interactive session, it seems ok if you also use grid.newpage(), but grid.newpage() gives error when building a knitr document. library(gridBase) plot.new() circle_size = unit(1, &quot;snpc&quot;) # snpc unit gives you a square region pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size, just = c(&quot;left&quot;, &quot;center&quot;))) par(omi = gridOMI(), new = TRUE) circlize_plot() upViewport() draw(lgd_list_vertical, x = circle_size, just = &quot;left&quot;) The legends can also be put at the bottom of the circular plot and it is just a matter how users arrange the grid viewports. In this case, all legends are changed to horizontal style, and three legends are packed horizontally as well. lgd_points = Legend(at = c(&quot;label1&quot;, &quot;label2&quot;), type = &quot;points&quot;, legend_gp = gpar(col = 2:3), title_position = &quot;topleft&quot;, title = &quot;Track1&quot;, nrow = 1) lgd_lines = Legend(at = c(&quot;label3&quot;, &quot;label4&quot;), type = &quot;lines&quot;, legend_gp = gpar(col = 4:5, lwd = 2), title_position = &quot;topleft&quot;, title = &quot;Track2&quot;, nrow = 1) lgd_links = Legend(at = c(-2, -1, 0, 1, 2), col_fun = col_fun, title_position = &quot;topleft&quot;, title = &quot;Links&quot;, direction = &quot;horizontal&quot;) lgd_list_horizontal = packLegend(lgd_points, lgd_lines, lgd_links, direction = &quot;horizontal&quot;) Similar code to arrange viewports. plot.new() pushViewport(viewport(x = 0.5, y = 1, width = circle_size, height = circle_size, just = c(&quot;center&quot;, &quot;top&quot;))) par(omi = gridOMI(), new = TRUE) circlize_plot() upViewport() draw(lgd_list_horizontal, y = unit(1, &quot;npc&quot;) - circle_size, just = &quot;top&quot;) "],["high-level-plots.html", "Chapter 5 Implement high-level circular plots 5.1 Circular barplots 5.2 Histograms 5.3 Phylogenetic trees 5.4 Manually create heatmaps", " Chapter 5 Implement high-level circular plots In this chapter, we show several examples which combine low-level graphic functions to construct complicated graphics for specific purposes. 5.1 Circular barplots circlize already has a circos.barplot() function that draws the barplots. Here is another type of circular barplots. In the following code, we put all the nine bars in one track and one sector. You can also put them into 9 tracks, but the code would be very similar. See Figure 5.1. category = paste0(&quot;category&quot;, &quot;_&quot;, 1:9) percent = sort(sample(40:80, 9)) color = rev(rainbow(length(percent))) library(circlize) circos.par(&quot;start.degree&quot; = 90, cell.padding = c(0, 0, 0, 0)) circos.initialize(&quot;a&quot;, xlim = c(0, 100)) # &#39;a` just means there is one sector circos.track(ylim = c(0.5, length(percent)+0.5), track.height = 0.8, bg.border = NA, panel.fun = function(x, y) { xlim = CELL_META$xlim circos.segments(rep(xlim[1], 9), 1:9, rep(xlim[2], 9), 1:9, col = &quot;#CCCCCC&quot;) circos.rect(rep(0, 9), 1:9 - 0.45, percent, 1:9 + 0.45, col = color, border = &quot;white&quot;) circos.text(rep(xlim[1], 9), 1:9, paste(category, &quot; - &quot;, percent, &quot;%&quot;), facing = &quot;downward&quot;, adj = c(1.05, 0.5), cex = 0.8) breaks = seq(0, 85, by = 5) circos.axis(h = &quot;top&quot;, major.at = breaks, labels = paste0(breaks, &quot;%&quot;), labels.cex = 0.6) }) Figure 5.1: A circular barplot. circos.clear() When adding text by circos.text(), adj is specified to c(1.05, 0.5) which means text is aligned to the right and there is also offset between the text and the anchor points. We can also use mm_x() to set the offset to absolute units. Conversion on x direction in a circular coordinate is affected by the position on y axis, here we must set the h argument. Following code can be used to replace the circos.text() in above example. circos.text(xlim[1] - mm_x(2, h = 1:9), 1:9, paste(category, &quot; - &quot;, percent, &quot;%&quot;), facing = &quot;downward&quot;, adj = c(1, 0.5), cex = 0.8) 5.2 Histograms circlize ships a circos.trackHist() function which draws histograms in cells. This function is a high-level function which caculates data ranges on y axes and creates a new track. The implement of this function is simple, that it first calculates the histogram in each cell by hist() function, then draws histogram by using circos.rect(). Users can choose to visualize data distributions by density lines by setting draw.density = TRUE. Figure 5.2 shows a histogram track under default settings, a histogram track with specified bin.size and a track with density lines. By default, bin size of histogram in each cell is calculated separatedly and they will be different between cells, which makes it not consistent to compare. Manually setting bin.size in all cells to a same value helps to compare the distributions between cells. x = rnorm(1600) sectors = sample(letters[1:16], 1600, replace = TRUE) circos.initialize(sectors, x = x) circos.trackHist(sectors, x = x, col = &quot;#999999&quot;, border = &quot;#999999&quot;) circos.trackHist(sectors, x = x, bin.size = 0.1, col = &quot;#999999&quot;, border = &quot;#999999&quot;) circos.trackHist(sectors, x = x, draw.density = TRUE, col = &quot;#999999&quot;, border = &quot;#999999&quot;) Figure 5.2: Histograms on circular layout. circos.clear() 5.3 Phylogenetic trees Circular dendrograms have many applications, one of which is to visualize phylogenetic trees. Basically, a phylogenetic tree is a dendrogram which is a combination of lines. In R, there are several classes that describe such type of tree such as hclust, dendrogram and phylo. In this example, we will demonstrate how to draw the tree from the dendrogram class. Nevertheless, other classes can be converted to dendrogram without too much difficulty. The bird.orders data we are using here is from ape package. This data set is related to species of birds. library(ape) data(bird.orders) hc = as.hclust(bird.orders) We split the tree into six sub trees by cutree() and convert the data into a dendrogram object. labels = hc$labels # name of birds ct = cutree(hc, 6) # cut tree into 6 pieces n = length(labels) # number of bird species dend = as.dendrogram(hc) As we mentioned before, the x-value for the phylogenetic tree is in fact index. Thus, the x-lim is just the minimum and maximum index of labels in the tree. Since there is only one phylogenetic tree, we only need one “big” sector. In the first track, we plot the name of each bird, with different colors to represent different sub trees. circos.par(cell.padding = c(0, 0, 0, 0)) circos.initialize(&quot;a&quot;, xlim = c(0, n)) # only one sector circos.track(ylim = c(0, 1), bg.border = NA, track.height = 0.3, panel.fun = function(x, y) { for(i in seq_len(n)) { circos.text(i-0.5, 0, labels[i], adj = c(0, 0.5), facing = &quot;clockwise&quot;, niceFacing = TRUE, col = ct[labels[i]], cex = 0.5) } }) In the above code, setting xlim to c(0, n) is very important because the leaves of the dendrogram are drawn at x = seq(0.5, n - 0.5). In the second track, we plot the circular dendrogram by circos.dendrogram() (Figure 5.3 left). You can render the dendrogram by dendextend package. suppressPackageStartupMessages(library(dendextend)) dend = color_branches(dend, k = 6, col = 1:6) dend_height = attr(dend, &quot;height&quot;) circos.track(ylim = c(0, dend_height), bg.border = NA, track.height = 0.4, panel.fun = function(x, y) { circos.dendrogram(dend) }) circos.clear() By default, dendrograms are facing outside of the circle (so that the labels should also be added outside the dendrogram). In circos.dendrogram(), you can set facing argument to inside to make them facing inside. In this case, dendrogram track is added first and labels are added later (Figure 5.3 right). circos.dendrogram(dend, facing = &quot;inside&quot;) Figure 5.3: A circular phylogenetic tree. If you look at the souce code of circos.dendrogram() and replace circos.lines() to lines(), actually the function can correctly make a dendrogram in the normal coordinate. With the flexibility of circlize package, it is easy to add more tracks if you want to add more corresponded information for the dendrogram to the plot. 5.4 Manually create heatmaps Heatmaps, and sometimes combined with dendrograms are frequently used to visualize e.g. gene expression. Heatmaps are basically composed by rectangles, thus, they can be implemented by circos.rect(). In following example, we make a circular plot with two heatmaps. First we generate the two matrix and perform clustring on the two matrix. mat = matrix(rnorm(100*10), nrow = 100, ncol = 10) col_fun = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;black&quot;, &quot;red&quot;)) sectors = rep(letters[1:2], times = c(30, 70)) mat_list = list(a = mat[sectors == &quot;a&quot;, ], b = mat[sectors == &quot;b&quot;, ]) dend_list = list(a = as.dendrogram(hclust(dist(mat_list[[&quot;a&quot;]]))), b = as.dendrogram(hclust(dist(mat_list[[&quot;b&quot;]])))) In the first track, columns in the matrix are adjusted by the clustering. Also note we use circos.rect() in a vectorized way. circos.par(cell.padding = c(0, 0, 0, 0), gap.degree = 5) circos.initialize(sectors, xlim = cbind(c(0, 0), table(sectors))) circos.track(ylim = c(0, 10), bg.border = NA, panel.fun = function(x, y) { sector.index = CELL_META$sector.index m = mat_list[[sector.index]] dend = dend_list[[sector.index]] m2 = m[order.dendrogram(dend), ] col_mat = col_fun(m2) nr = nrow(m2) nc = ncol(m2) for(i in 1:nc) { circos.rect(1:nr - 1, rep(nc - i, nr), 1:nr, rep(nc - i + 1, nr), border = col_mat[, i], col = col_mat[, i]) } }) Since there are two dendrograms, it is important to make the height of both dendrogram in a same scale. We calculate the maximum height of the two dendrograms and set it to ylim of the second track (Figure 5.4). max_height = max(sapply(dend_list, function(x) attr(x, &quot;height&quot;))) circos.track(ylim = c(0, max_height), bg.border = NA, track.height = 0.3, panel.fun = function(x, y) { sector.index = get.cell.meta.data(&quot;sector.index&quot;) dend = dend_list[[sector.index]] circos.dendrogram(dend, max_height = max_height) }) circos.clear() Figure 5.4: Circular heatmaps. In the next chapter, we will introduce a high-level function circos.heatmap() which draws fancy circular heatmaps. "],["circos-heatmap.html", "Chapter 6 The circos.heatmap() function 6.1 Input data 6.2 Circular layout 6.3 Dendrograms and row names 6.4 Clustering 6.5 Callback on dendrograms 6.6 Multiple heatmap tracks 6.7 With other tracks 6.8 Add annotations 6.9 A complex example of circular heatmaps", " Chapter 6 The circos.heatmap() function Circular heatmaps are pretty. With circlize package, it is possible to implement circular heatmaps by the low-level function circos.rect() as described in previous Chapter. From version 0.4.10, there is a new high-level function circos.heatmap() which greatly simplifies the creation of circular heatmaps. In this section, I will demostrate the usage of the new circos.heatmap() function. First let’s generate a random matrix and randomly split it into five groups. set.seed(123) mat1 = rbind(cbind(matrix(rnorm(50*5, mean = 1), nr = 50), matrix(rnorm(50*5, mean = -1), nr = 50)), cbind(matrix(rnorm(50*5, mean = -1), nr = 50), matrix(rnorm(50*5, mean = 1), nr = 50)) ) rownames(mat1) = paste0(&quot;R&quot;, 1:100) colnames(mat1) = paste0(&quot;C&quot;, 1:10) mat1 = mat1[sample(100, 100), ] # randomly permute rows split = sample(letters[1:5], 100, replace = TRUE) split = factor(split, levels = letters[1:5]) Following plot is the normal layout of the heatmap (by the ComplexHeatmap package). library(ComplexHeatmap) Heatmap(mat1, row_split = split) Figure 6.1: A normal heatmap. In the next sections, I will demonstrate how to visualize it circularly. 6.1 Input data The input for circos.heatmap() should be a matrix (or a vector which will be converted to a one-column matrix). If the matrix is split into groups, a categorical variable must be specified with the split argument. Note the value of spilt should be a character vector or a factor. If it is a numeric vector, it is converted to characters internally. Colors are important aesthetic mappings for the values in the matrix. In circos.heatmap(), users must specify col argument with a user-defined color schema. If the matrix is continuous numeric, value for col should be a color mapping generated by colorRamp2(), and if the matrix is in characters, value of col should be a named color vector. Following plot is the circular version of the previous heatmap. Note the matrix rows distribute in the circular direction and the matrix columns distribute in the radical direction. In following plot, the circle is split into five sectors where each sector corresponds to one row group. library(circlize) # &gt;= 0.4.10 col_fun1 = colorRamp2(c(-2, 0, 2), c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;)) circos.heatmap(mat1, split = split, col = col_fun1) Figure 6.2: A circular heatmap which has been split. circos.clear() There is one thing very important that is after creating the circular heatmap, you must call circos.clear() to remove the layout completely. I will explain this point later in this post. If split is not specified, there is only one big sector that contains the complete heatmap. circos.heatmap(mat1, col = col_fun1) Figure 6.3: A circular heatmap which no split. circos.clear() 6.2 Circular layout Similar as other circular plots generated by circlize package, the circular layout can be controlled by circos.par() before making the plot. The parameters for the heatmap track can be controlled in circos.heatmap() function, such as track.height (height of the track) and bg.border (border of the track). In the following example, the labels for the sectors are added by setting the show.sector.labels argument. The order of sectors is c(\"a\", \"b\", \"c\", \"d\", \"e\") clock-wisely. You can see in the following plot, sector a starts from \\(\\theta = 90^{\\circ}\\). circos.par(start.degree = 90, gap.degree = 10) circos.heatmap(mat1, split = split, col = col_fun1, track.height = 0.4, bg.border = &quot;green&quot;, bg.lwd = 2, bg.lty = 2, show.sector.labels = TRUE) Figure 6.4: Circular heatmap. Control the layout. circos.clear() If the value for split argument is a factor, the order of the factor levels controls the order of heatmaps. If split is a simple vector, the order of heatmaps is unique(split). # note since circos.clear() was called in the previous plot, # now the layout starts from theta = 0 (the first sector is &#39;e&#39;) circos.heatmap(mat1, split = factor(split, levels = c(&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;)), col = col_fun1, show.sector.labels = TRUE) Figure 6.5: Circular heatmap. Control the order of heatmaps. circos.clear() 6.3 Dendrograms and row names By default, the numeric matrix is clustered on rows, thus, there are dendrograms generated from the clustering. dend.side argument controls the position of dendrograms relative to the heatmap track. Note, the dendrograms are on a separated track. circos.heatmap(mat1, split = split, col = col_fun1, dend.side = &quot;inside&quot;) circos.clear() circos.heatmap(mat1, split = split, col = col_fun1, dend.side = &quot;outside&quot;) circos.clear() Figure 6.6: Circular heatmap. Control the dendrograms. The height of the dendrograms is controlled by dend.track.height argument. Row names of the matrix can be drawn by setting rownames.side argument. Row names are also drawn in a separated track. circos.heatmap(mat1, split = split, col = col_fun1, rownames.side = &quot;inside&quot;) circos.clear() text(0, 0, &#39;rownames.side = &quot;inside&quot;&#39;) circos.heatmap(mat1, split = split, col = col_fun1, rownames.side = &quot;outside&quot;) circos.clear() text(0, 0, &#39;rownames.side = &quot;outside&quot;&#39;) Figure 6.7: Circular heatmap. Control the row names. Row names of the matrix and the dendrograms can be both drawn. Of course, they cannot be on the same side of the heatmap track. circos.heatmap(mat1, split = split, col = col_fun1, dend.side = &quot;inside&quot;, rownames.side = &quot;outside&quot;) circos.clear() circos.heatmap(mat1, split = split, col = col_fun1, dend.side = &quot;outside&quot;, rownames.side = &quot;inside&quot;) circos.clear() Figure 6.8: Circular heatmap. Control both the dendrograms and row names. Graphic parameters for row names can be set as a scalar or a vector with the length same as the number of rows in the matrix. circos.heatmap(mat1, split = split, col = col_fun1, rownames.side = &quot;outside&quot;, rownames.col = 1:nrow(mat1) %% 10 + 1, rownames.cex = runif(nrow(mat1), min = 0.3, max = 2), rownames.font = 1:nrow(mat1) %% 4 + 1) Figure 6.9: Circular heatmap. Control graphic parameters for row names. circos.clear() The graphic parameters of dendrogram can be set by directly rendering the dendrograms through a callback function, as will be demonstrated later. 6.4 Clustering By default, the numeric matrix is clustered on rows. cluster argument can be set to FALSE to turn off the clustering. Of course, when cluster is set to FALSE, no dendrogram is drawn even if dend.side is set. circos.heatmap(mat1, split = split, cluster = FALSE, col = col_fun1) circos.clear() Figure 6.10: Circular heatmap. Control clusterings. Clustering method and distance method are controlled by clustering.method and distance.method arguments. Please note circos.heatmap() does not directly support clustering on matrix columns. You should apply column reordering before send to circos.heatmap(), e.g., column_od = hclust(dist(t(mat1)))$order circos.heatmap(mat1[, column_od]) circos.clear() 6.5 Callback on dendrograms The clustering generates dendrograms. Callback function can be applied to every dendrogram after it is generated in the corresponding sector. The callback function edits the dendrograms such as 1. reorder the dendrograms, or 2. color the dendrograms. In circos.heatmap(), a user-defined function should be set to dend.callback argument. The user-defined function should have three arguments: dend: The dendrogram in the current sector. m: The sub-matrix that corresponds to the current sector. si: The sector index (or the sector name) for the current sector. The default callback function is defined as follows and it reorders the dendrogram by weighting the matrix row means. function(dend, m, si) reorder(dend, rowMeans(m)) Following example reorders the dendrograms in every sector by dendsort::dendsort(). library(dendsort) circos.heatmap(mat1, split = split, col = col_fun1, dend.side = &quot;inside&quot;, dend.callback = function(dend, m, si) { dendsort(dend) } ) circos.clear() Figure 6.11: Circular Heatmap. Reorder dendrograms. We can use color_branches() from dendextend package to render the dendrogram edges. E.g., to assign different colors for the dendrograms in the five sectors. Here the height of the dendrogram track is increased by the dend.track.height argument. library(dendextend) dend_col = structure(1:5, names = letters[1:5]) circos.heatmap(mat1, split = split, col = col_fun1, dend.side = &quot;inside&quot;, dend.track.height = 0.2, dend.callback = function(dend, m, si) { # when k = 1, it renders one same color for the whole dendrogram color_branches(dend, k = 1, col = dend_col[si]) } ) Figure 6.12: Circular heatmap. Render dendrograms that were split. circos.clear() Or if the matrix is not split, we can assign the sub-dendrograms with different colors. circos.heatmap(mat1, col = col_fun1, dend.side = &quot;inside&quot;, dend.track.height = 0.2, dend.callback = function(dend, m, si) { color_branches(dend, k = 4, col = 2:5) } ) Figure 6.13: Circular heatmap. Render dendrograms. circos.clear() 6.6 Multiple heatmap tracks If you make a circular plot which only contains one heatmap track, using circos.heatmap() is very straightforward. If you make a more complex circular plot which contains multiple tracks, there are more details on circos.heatmap() you should know. The first call of circos.heatmap() actually initializes the layout, i.e., applying clustering and splitting the matrix. The dendrograms and split variable are stored internally. This is why you should explicitly call circos.clear() to remove all the internal variables so that it can ensure when you make a new circular heatmap, the first call of circos.heatmap() is in a clean environment. The first call of circos.heatmap() determines the row ordering (the order in the circular direction) for all tracks, thus, matrices in the following tracks share the same row ordering as in the first track. Also, the matrices in the following tracks are also split accordingly to the split in the first heatmap track. If clustering is not applied in the first heatmap track, the natural ordering of rows (i.e., c(1, 2, ..., n)) is used. mat2 = mat1[sample(100, 100), ] # randomly permute mat1 by rows col_fun2 = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)) circos.heatmap(mat1, split = split, col = col_fun1, dend.side = &quot;outside&quot;) circos.heatmap(mat2, col = col_fun2) circos.clear() If I switch the two tracks, you can see now the clustering is controlled by the first heatmap track which is the green-red heatmap track. circos.heatmap(mat2, split = split, col = col_fun2, dend.side = &quot;outside&quot;) circos.heatmap(mat1, col = col_fun1) circos.clear() You might want to ask, what if I don’t want the clustering to be determined by the first track, while the second or the third track? The solution is simple. As I mentioned, the first call of circos.heatmap() initializes the layout. Actually the initialization can be manually done by explicitly calling circos.heatmap.initialize() function which circos.heatmap() internally calls. In circos.heatmap.initialize(), you specify whatever matrix you want to apply clustering as well as the split variable, then, the following circos.heatmap() calls all share this layout. In the following example, the global layout is determined by mat1 which is visualized in the second track. I set dend.side = \"outside\" in the first track and actually you can find the dendrograms are actually generatd based on the matrix in the second track. circos.heatmap.initialize(mat1, split = split) circos.heatmap(mat2, col = col_fun2, dend.side = &quot;outside&quot;) circos.heatmap(mat1, col = col_fun1) circos.clear() In the next example, the heatmap layout is generated from mat1, while the two heatmap tracks only contain five columns for each. circos.heatmap.initialize(mat1, split = split) circos.heatmap(mat1[, 1:5], col = col_fun1) circos.heatmap(mat1[, 6:10], col = col_fun1) circos.clear() 6.7 With other tracks circos.heatmap() can also be integrated with other non-heatmap tracks, however, it is a little bit tricky. In the circular layout, values on x-axes and y-axes are just the numeric indices. Assume there are nr rows and nc columns for the heatmap in a sector, the heatmap rows are drawn in intervals of (0, 1), c(1, 2), …, c(nr-1, nr) and similar for the heatmap columns. Also the original matrix is reordered. All these effects need to be considered if more tracks are added to make sure to have the correct correspondance to the heatmap track. After the heatmap layout is done, additional information for the tracks/sectors/cells can be retrieved by the special variable CELL_META. The additional meta data for the cell/sector are listed as follows and they are important for correctly corresponding to the heatmap track. CELL_META$row_dend or simply CELL_META$dend: the dendrogram in the current sector. If no clustering was done, the value is NULL. CELL_META$row_order or simply CELL_META$order: the row ordering of the sub-matrix in the current sector after clustering. If no clustering was done, the value is c(1, 2, ..., ). CELL_META$subset: The subset of indices in the original complete matrix. The values are sorted increasing. Following are the outputs of CELL_META$row_dend, CELL_META$row_order and CELL_META$subset in the first sector in the example circular heatmap. CELL_META$row_dend ## &#39;dendrogram&#39; with 2 branches and 14 members total, at height 10.51736 CELL_META$row_order ## [1] 2 6 4 12 8 1 5 10 7 9 13 11 3 14 CELL_META$subset ## [1] 8 9 14 18 20 37 55 62 66 72 78 85 93 97 In following example, I add a track which visualizes the row means of the first five columns in mat1. I added cell.padding = c(0.02, 0, 0.02, 0) so that the maximal and minimal points won’t overlap with the top and bottom borders of the cells. circos.heatmap(mat1, split = split, col = col_fun1) row_mean = rowMeans(mat1[, 1:5]) circos.track(ylim = range(row_mean), panel.fun = function(x, y) { y = row_mean[CELL_META$subset] y = y[CELL_META$row_order] circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = &quot;grey&quot;) circos.points(seq_along(y) - 0.5, y, col = ifelse(y &gt; 0, &quot;red&quot;, &quot;blue&quot;)) }, cell.padding = c(0.02, 0, 0.02, 0)) circos.clear() Similarly, if the points track is put as the first track, the layout should be initialized in advance. circos.heatmap.initialize(mat1, split = split) # This is the same as the previous example circos.track(ylim = range(row_mean), panel.fun = function(x, y) { y = row_mean[CELL_META$subset] y = y[CELL_META$row_order] circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = &quot;grey&quot;) circos.points(seq_along(y) - 0.5, y, col = ifelse(y &gt; 0, &quot;red&quot;, &quot;blue&quot;)) }, cell.padding = c(0.02, 0, 0.02, 0)) circos.heatmap(mat1, col = col_fun1) # no need to specify &#39;split&#39; here circos.clear() Boxplots are very frequently used to correspond to the matrix rows. circos.heatmap(mat1, split = split, col = col_fun1) circos.track(ylim = range(mat1), panel.fun = function(x, y) { m = mat1[CELL_META$subset, 1:5, drop = FALSE] m = m[CELL_META$row_order, , drop = FALSE] n = nrow(m) # circos.boxplot is applied on matrix columns, so here we transpose it. circos.boxplot(t(m), pos = 1:n - 0.5, pch = 16, cex = 0.3) circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = &quot;grey&quot;) }, cell.padding = c(0.02, 0, 0.02, 0)) circos.clear() 6.8 Add annotations The labels for the sectors can be added by setting show.sector.labels = TRUE, however, this does not provide any customization on the labels. Users can customize their own labels by self-defining a panel.fun function, demonstrated as follows. Here the labels are added 2mm away from the heatmap track (by convert_y(2, \"mm\") which defines the offset in the y-direction). Here I set track.index = get.current.track.index() to make sure the labels are always added in the correct track. circos.heatmap(mat1, split = split, col = col_fun1) circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$cell.ylim[2] + convert_y(2, &quot;mm&quot;), paste0(&quot;this is group &quot;, CELL_META$sector.index), facing = &quot;bending.inside&quot;, cex = 0.8, adj = c(0.5, 0), niceFacing = TRUE) }, bg.border = NA) circos.clear() Column names of the matrix are not directly supported by circos.heatmap(), but they can be easily added also by self-defining a panel.fun function. In followig example, I set larger space (10 degrees, users normally need to try several values to get a best space) after the last sector (the fifth sector) by gap.after parameter in circos.par(), later I draw the column names in the last sector in panel.fun. circos.par(gap.after = c(2, 2, 2, 2, 10)) circos.heatmap(mat1, split = split, col = col_fun1, track.height = 0.4) circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { if(CELL_META$sector.numeric.index == 5) { # the last sector cn = colnames(mat1) n = length(cn) circos.text(rep(CELL_META$cell.xlim[2], n) + convert_x(1, &quot;mm&quot;), 1:n - 0.5, cn, cex = 0.5, adj = c(0, 0.5), facing = &quot;inside&quot;) } }, bg.border = NA) circos.clear() Next example adds rectangles and labels to show the two groups of columns in the matrix. The code inside panel.fun is simple. It basically draws rectangles and texts. convert_x() converts a unit on the x-direction to a proper value measured in tbe circular coordinate system. circos.par(gap.after = c(2, 2, 2, 2, 10)) circos.heatmap(mat1, split = split, col = col_fun1, track.height = 0.4) circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { if(CELL_META$sector.numeric.index == 5) { # the last sector circos.rect(CELL_META$cell.xlim[2] + convert_x(1, &quot;mm&quot;), 0, CELL_META$cell.xlim[2] + convert_x(5, &quot;mm&quot;), 5, col = &quot;orange&quot;, border = NA) circos.text(CELL_META$cell.xlim[2] + convert_x(3, &quot;mm&quot;), 2.5, &quot;group 1&quot;, cex = 0.5, facing = &quot;clockwise&quot;) circos.rect(CELL_META$cell.xlim[2] + convert_x(1, &quot;mm&quot;), 5, CELL_META$cell.xlim[2] + convert_x(5, &quot;mm&quot;), 10, col = &quot;pink&quot;, border = NA) circos.text(CELL_META$cell.xlim[2] + convert_x(3, &quot;mm&quot;), 7.5, &quot;group 2&quot;, cex = 0.5, facing = &quot;clockwise&quot;) } }, bg.border = NA) circos.clear() circlize does not generates legends, but the legends can be manually generated by ComplexHeatmap::Legend() function and added to the circular plot. Following is a simple example of adding a legend. In the next section, you can find a more complex example of adding many legends. circos.heatmap(mat1, split = split, col = col_fun1) circos.clear() library(ComplexHeatmap) lgd = Legend(title = &quot;mat1&quot;, col_fun = col_fun1) grid.draw(lgd) 6.9 A complex example of circular heatmaps In this section, I will demonstrate how to make complex circular heatmaps. The heatmaps in the normal layout are in the following figure and now I will change them with the circular layout. The heatmaps visualize correlations between DNA methylation, gene expression and other genome-level information. You can go to this link to see how the original heatmaps were generated. The original heatmaps were generated with random datasets. The code for generating them is available at https://gist.github.com/jokergoo/0ea5639ee25a7edae3871ed8252924a1. Here I just directly source the script from Gist. source(&quot;https://gist.githubusercontent.com/jokergoo/0ea5639ee25a7edae3871ed8252924a1/raw/57ca9426c2ed0cebcffd79db27a024033e5b8d52/random_matrices.R&quot;) Similar as the original heatmap, rows of all heatmaps are split into 5 groups by applying k-means clustering on rows of the methylation matrix (mat_meth). set.seed(123) km = kmeans(mat_meth, centers = 5)$cluster Now there are following matrices/vectors that need to be visualized as heatmaps: mat_meth: a matrix in which rows correspond to differetially methylated regions (DMRs). The value in the matrix is the mean methylation level in the DMR in every sample. mat_expr: a matrix in which rows correspond to genes which are associated to the DMRs (i.e. the nearest gene to the DMR). The value in the matrix is the expression level for each gene in each sample. Expression is scaled for every gene across samples. direction: direction of the methylation change (hyper meaning higher methylation in tumor samples, hypo means lower methylation in tumor samples). cor_pvalue: p-value for the correlation test between methylation and expression of the associated gene. Values are -log10 transformed. gene_type: type of the genes (e.g., protein coding genes or lincRNAs). anno_gene: annotation to the gene models (i.e., intergenic, intragenic or transcription start site (TSS)). dist: distance from DMRs to TSS of the assiciated genes. anno_enhancer: fraction of each DMR that overlaps enhancers. Among these variables, mat_meth, mat_expr, cor_pvalue, dist and anno_enhancer are numeric and I set color mapping functions for them. For the others I set named color vectors. In the following code, I specify split in the first call of circos.heatmap() which is the methylation heatmap. The track heights are manually adjusted. col_meth = colorRamp2(c(0, 0.5, 1), c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;)) circos.heatmap(mat_meth, split = km, col = col_meth, track.height = 0.12) col_direction = c(&quot;hyper&quot; = &quot;red&quot;, &quot;hypo&quot; = &quot;blue&quot;) circos.heatmap(direction, col = col_direction, track.height = 0.01) col_expr = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)) circos.heatmap(mat_expr, col = col_expr, track.height = 0.12) col_pvalue = colorRamp2(c(0, 2, 4), c(&quot;white&quot;, &quot;white&quot;, &quot;red&quot;)) circos.heatmap(cor_pvalue, col = col_pvalue, track.height = 0.01) library(RColorBrewer) col_gene_type = structure(brewer.pal(length(unique(gene_type)), &quot;Set3&quot;), names = unique(gene_type)) circos.heatmap(gene_type, col = col_gene_type, track.height = 0.01) col_anno_gene = structure(brewer.pal(length(unique(anno_gene)), &quot;Set1&quot;), names = unique(anno_gene)) circos.heatmap(anno_gene, col = col_anno_gene, track.height = 0.01) col_dist = colorRamp2(c(0, 10000), c(&quot;black&quot;, &quot;white&quot;)) circos.heatmap(dist, col = col_dist, track.height = 0.01) col_enhancer = colorRamp2(c(0, 1), c(&quot;white&quot;, &quot;orange&quot;)) circos.heatmap(anno_enhancer, col = col_enhancer, track.height = 0.03) circos.clear() The circular heatmaps look pretty! Since rows in the matrices are genomic regions (the differentially methylated regions), if we can establish connections between some of the regions, e.g. physical interactions in the 3D chromosome structure, the plot would be nicer and more useful. In following code, I generate some random interactions between DMRs. Each row in df_link means there is an interaction from the ith DMR to the jth DMR. df_link = data.frame( from_index = sample(nrow(mat_meth), 20), to_index = sample(nrow(mat_meth), 20) ) Finding the positions of these DMRs on the circular heatmaps is tricky. Check the comments in the following code. Note here the subset and row_order meta data are retrieved by get.cell.meta.data() function by explicitly specifying the sector index. for(i in seq_len(nrow(df_link))) { # Let&#39;s call the DMR with index df_link$from_index[i] as DMR1, # and the other one with index df_link$to_index[i] as DMR2. # The sector where DMR1 is in. group1 = km[ df_link$from_index[i] ] # The sector where DMR2 is in. group2 = km[ df_link$to_index[i] ] # The subset of DMRs (row indices from mat_meth) in sector `group1`. subset1 = get.cell.meta.data(&quot;subset&quot;, sector.index = group1) # The row ordering in sector `group1`. row_order1 = get.cell.meta.data(&quot;row_order&quot;, sector.index = group1) # This is the position of DMR1 in the `group1` heatmap. x1 = which(subset1[row_order1] == df_link$from_index[i]) # The subset of DMRs (row indices from mat_meth) in sector `group2`. subset2 = get.cell.meta.data(&quot;subset&quot;, sector.index = group2) # The row ordering in sector `group2`. row_order2 = get.cell.meta.data(&quot;row_order&quot;, sector.index = group2) # This is the position of DMR2 in the `group2` heatmap. x2 = which(subset2[row_order2] == df_link$to_index[i]) # We take the middle point and draw a link between DMR1 and DMR2 circos.link(group1, x1 - 0.5, group2, x2 - 0.5, col = rand_color(1)) } To make things easier, I implemented a function circos.heatmap.link() that basically wraps the code above. Now drawing links between matrix rows is simpler: for(i in seq_len(nrow(df_link))) { circos.heatmap.link(df_link$from_index[i], df_link$to_index[i], col = rand_color(1)) } After adding the links, the plots look nicer! Legends are important for understanding heatmaps. Unfortunately, circlize does not naturally support legends, however, the circlize plots can be combined with the legends generated from ComplexHeatmap::Legend(). Following the instructions from that link, we need a function that draws the circlize plot and a Legends object (which is a grid::grob object). The function that draws the circular plot is simply a wrapper of the previous code without any modification. circlize_plot = function() { circos.heatmap(mat_meth, split = km, col = col_meth, track.height = 0.12) circos.heatmap(direction, col = col_direction, track.height = 0.01) circos.heatmap(mat_expr, col = col_expr, track.height = 0.12) circos.heatmap(cor_pvalue, col = col_pvalue, track.height = 0.01) circos.heatmap(gene_type, col = col_gene_type, track.height = 0.01) circos.heatmap(anno_gene, col = col_anno_gene, track.height = 0.01) circos.heatmap(dist, col = col_dist, track.height = 0.01) circos.heatmap(anno_enhancer, col = col_enhancer, track.height = 0.03) for(i in seq_len(nrow(df_link))) { circos.heatmap.link(df_link$from_index[i], df_link$to_index[i], col = rand_color(1)) } circos.clear() } The legends can be generated from the color mapping functions and color vectors. The ComplexHeatmap::Legend() function is very flexible that you can customize the labels on the legends (see how lgd_pvalue, lgd_dist and lgd_enhancer are defined). lgd_meth = Legend(title = &quot;Methylation&quot;, col_fun = col_meth) lgd_direction = Legend(title = &quot;Direction&quot;, at = names(col_direction), legend_gp = gpar(fill = col_direction)) lgd_expr = Legend(title = &quot;Expression&quot;, col_fun = col_expr) lgd_pvalue = Legend(title = &quot;P-value&quot;, col_fun = col_pvalue, at = c(0, 2, 4), labels = c(1, 0.01, 0.0001)) lgd_gene_type = Legend(title = &quot;Gene type&quot;, at = names(col_gene_type), legend_gp = gpar(fill = col_gene_type)) lgd_anno_gene = Legend(title = &quot;Gene anno&quot;, at = names(col_anno_gene), legend_gp = gpar(fill = col_anno_gene)) lgd_dist = Legend(title = &quot;Dist to TSS&quot;, col_fun = col_dist, at = c(0, 5000, 10000), labels = c(&quot;0kb&quot;, &quot;5kb&quot;, &quot;10kb&quot;)) lgd_enhancer = Legend(title = &quot;Enhancer overlap&quot;, col_fun = col_enhancer, at = c(0, 0.25, 0.5, 0.75, 1), labels = c(&quot;0%&quot;, &quot;25%&quot;, &quot;50%&quot;, &quot;75%&quot;, &quot;100%&quot;)) Now we use the gridBase to combine both base graphics (circlize is implemented with the base graphics) and grid graphics (ComplexHeatmap is implemented with the grid graphics). You can just use the following code as a template for your plot if you want to try. And, BINGO! Wie schön!! library(gridBase) plot.new() circle_size = unit(1, &quot;snpc&quot;) # snpc unit gives you a square region pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size, just = c(&quot;left&quot;, &quot;center&quot;))) par(omi = gridOMI(), new = TRUE) circlize_plot() upViewport() h = dev.size()[2] lgd_list = packLegend(lgd_meth, lgd_direction, lgd_expr, lgd_pvalue, lgd_gene_type, lgd_anno_gene, lgd_dist, lgd_enhancer, max_height = unit(0.9*h, &quot;inch&quot;)) draw(lgd_list, x = circle_size, just = &quot;left&quot;) "],["advanced-layout.html", "Chapter 7 Advanced layout 7.1 Zooming of sectors 7.2 Visualize part of the circle 7.3 Combine multiple circular plots 7.4 Arrange multiple plots", " Chapter 7 Advanced layout 7.1 Zooming of sectors In this section, we will introduce how to zoom sectors and put the zoomed sectors at the same track as the original sectors. Under the default settings, width of sectors are calculated according to the data range in corresponding categories. Normally it is not a good idea to manually modify the default sector width since it reflects useful information of your data. However, sometimes manually modifying the width of sectors can make more advanced plots, e.g. zoomings. The basic idea for zooming is to put original sectors on part of the circle and put the zoomed sectors on the other part, so that in the original sectors, widths are still proportional to their data ranges, and in the zoomed sectors, the widths are also proportional to the data ranges in the zoomed sectors. This type of zooming is rather simple to implement. All we need to do is to copy the data which corresponds to the zoomed sectors, assign new category names to them and append to the original data. The good thing is since the data in the zoomed sectors is exactly the same as the original sectors, if you treat them as normal categories, the graphics will be exactly the same as in the original sectors, but with x direction zoomed. Following example shows more clearly the basic idea of this “horizontal” zooming. We first generate a data frame with six categories. set.seed(123) df = data.frame( sectors = sample(letters[1:6], 400, replace = TRUE), x = rnorm(400), y = rnorm(400), stringsAsFactors = FALSE ) We want to zoom sector a and the first 10 points in sector b. First we extract these data and format as a new data frame. zoom_df_a = df[df$sectors == &quot;a&quot;, ] zoom_df_b = df[df$sectors == &quot;b&quot;, ] zoom_df_b = zoom_df_b[order(zoom_df_b[, 2])[1:10], ] zoom_df = rbind(zoom_df_a, zoom_df_b) Then we need to change the sector names in the zoomed data frame. Here we just simply add “zoom_” prefix to the original names to show that they are “zoomed” sectors. After that, it is attached to the original data frame. zoom_df$sectors = paste0(&quot;zoom_&quot;, zoom_df$sectors) df2 = rbind(df, zoom_df) In this example, we will put the original cells in the left half of the circle and the zoomed sectors in the right. As we have already mentioned before, we simply normalize the width of normal sectors and normalize the width of zoomed sectors separately. Note now the sum of the sector width for the original sectors is 1 and the sum of sector width for the zoomed sectors is 1, which means these two types of sectors have their own half circle. You may notice the sum of the sector.width is not idential to 1. This is fine, they will be further normalized to 1 internally. Strictly speaking, since the gaps between sectors are not taken into consideration, the width of the original sectors are not exactly 180 degree, but the real value is quite close to it. xrange = tapply(df2$x, df2$sectors, function(x) max(x) - min(x)) normal_sector_index = unique(df$sectors) zoomed_sector_index = unique(zoom_df$sectors) sector.width = c(xrange[normal_sector_index] / sum(xrange[normal_sector_index]), xrange[zoomed_sector_index] / sum(xrange[zoomed_sector_index])) sector.width ## c f b e d a zoom_a zoom_b ## 0.1774352 0.1649639 0.1685275 0.1662047 0.1668505 0.1560182 0.7237996 0.2762004 What to do next is just to make the circular plot in the normal way. All the graphics in sector a and b will be automatically zoomed to sector “zoom_a” and “zoom_b”. In following code, since the sector names are added outside the first track, points.overflow.warning is set to FALSE to turn off the warning messages. circos.par(start.degree = 90, points.overflow.warning = FALSE) circos.initialize(df2$sectors, x = df2$x, sector.width = sector.width) circos.track(df2$sectors, x = df2$x, y = df2$y, panel.fun = function(x, y) { circos.points(x, y, col = &quot;red&quot;, pch = 16, cex = 0.5) circos.text(CELL_META$xcenter, CELL_META$cell.ylim[2] + mm_y(2), CELL_META$sector.index, niceFacing = TRUE) }) Adding links from original sectors to zoomed sectors is a good idea to show where the zooming occurs (Figure 7.1). Notice that we manually adjust the position of one end of the sector b link. circos.link(&quot;a&quot;, get.cell.meta.data(&quot;cell.xlim&quot;, sector.index = &quot;a&quot;), &quot;zoom_a&quot;, get.cell.meta.data(&quot;cell.xlim&quot;, sector.index = &quot;zoom_a&quot;), border = NA, col = &quot;#00000020&quot;) circos.link(&quot;b&quot;, c(zoom_df_b[1, 2], zoom_df_b[10, 2]), &quot;zoom_b&quot;, get.cell.meta.data(&quot;cell.xlim&quot;, sector.index = &quot;zoom_b&quot;), rou1 = get.cell.meta.data(&quot;cell.top.radius&quot;, sector.index = &quot;b&quot;), border = NA, col = &quot;#00000020&quot;) circos.clear() Figure 7.1: Zoom sectors. Chapter 13 introduces another type of zooming by combining two circular plots. 7.2 Visualize part of the circle canvas.xlim and canvas.ylim parameters in circos.par() are useful to generate plots only in part of the circle. As mentioned in previews chapters, the circular plot is always drawn in a canvas where x values range from -1 to 1 and y values range from -1 to 1. Thus, if canvas.xlim and canvas.ylim are all set to c(0, 1), which means, the canvas is restricted to the right top part, then only sectors between 0 to 90 degree are visible (Figure 7.2). Figure 7.2: One quarter of the circle. To make the right plot in Figure 7.2, we only need to set one sector in the layout and set gap.after to 270. (One sector with gap.after of 270 degree means the width of this sector is exactly 90 degree.) circos.par(&quot;canvas.xlim&quot; = c(0, 1), &quot;canvas.ylim&quot; = c(0, 1), &quot;start.degree&quot; = 90, &quot;gap.after&quot; = 270) sectors = &quot;a&quot; # this is the name of your sector circos.initialize(sectors = sectors, xlim = ...) ... Similar idea can be applied to the circle where in some tracks, only a subset of cells are needed. Gererally there are two ways. The first way is to create the track and add graphics with subset of data that only corresponds to the cells that are needed. And the second way is to create an empty track first and customize the cells by circos.update(). Following code illustrates the two methods (Figure 7.3). sectors = letters[1:4] circos.initialize(sectors, xlim = c(0, 1)) # directly specify the subset of data df = data.frame(sectors = rep(&quot;a&quot;, 100), x = runif(100), y = runif(100)) circos.track(df$sectors, x = df$x, y = df$y, panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5) }) # create empty track first then fill graphics in the cell circos.track(ylim = range(df$y), bg.border = NA) circos.update(sector.index = &quot;a&quot;, bg.border = &quot;black&quot;) circos.points(df$x, df$y, pch = 16, cex = 0.5) circos.track(sectors = sectors, ylim = c(0, 1)) circos.track(sectors = sectors, ylim = c(0, 1)) Figure 7.3: Show subset of cells in tracks. circos.clear() 7.3 Combine multiple circular plots circlize finally makes the circular plot in the base R graphic system. Seperated circular plots actually can be put in a same page by some tricks from the base graphic system. Here the key is par(new = TRUE) which allows to draw a new figure as a new layer directly on the previous canvas region. By setting different canvas.xlim and canvas.ylim, it allows to make more complex plots which include more than one circular plots. Folowing code shows how the two independent circualr plots are added and nested. Figure 7.4 illustrates the invisible canvas coordinate and how the two circular plots overlap. sectors = letters[1:4] circos.initialize(sectors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(0.5, 0.5, &quot;outer circos&quot;, niceFacing = TRUE) }) circos.clear() par(new = TRUE) # &lt;- magic circos.par(&quot;canvas.xlim&quot; = c(-2, 2), &quot;canvas.ylim&quot; = c(-2, 2)) sectors = letters[1:3] circos.initialize(sectors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(0.5, 0.5, &quot;inner circos&quot;, niceFacing = TRUE) }) circos.clear() Figure 7.4: Nested circular plots. The second example (Figure 7.5) makes a plot where two circular plots separate from each other. You can use technique introduced in Section 7.2 to only show part of the circle, select proper canvas.xlim and canvas.ylim, and finally arrange the two plots into one page. The source code for generating Figure 7.5 is at https://github.com/jokergoo/circlize_book/blob/master/src/intro-20-separated.R. Figure 7.5: Two separated circular plots The third example is to draw cells with different radius (Figure 7.6). In fact, it makes four circular plots where only one sector for each plot is plotted. sectors = letters[1:4] lim = c(1, 1.1, 1.2, 1.3) for(i in 1:4) { circos.par(&quot;canvas.xlim&quot; = c(-lim[i], lim[i]), &quot;canvas.ylim&quot; = c(-lim[i], lim[i]), &quot;track.height&quot; = 0.4) circos.initialize(sectors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), bg.border = NA) circos.update(sector.index = sectors[i], bg.border = &quot;black&quot;) circos.points(runif(10), runif(10), pch = 16) circos.clear() par(new = TRUE) } par(new = FALSE) Figure 7.6: Cells with differnet radius. Note above plot is different from the example in Figure 7.3. In Figure 7.3, cells both visible and invisible all belong to a same track and they are in a same circular plot, thus they should have same radius. But for the example here, cells have different radius and they belong to different circular plot. In chapter 13, we use this technique to implement zoomings by combining two circular plots. 7.4 Arrange multiple plots circlize is implemented in the base R graphic system, thus, you can use layout() or par(\"mfrow\")/par(\"mfcol\") to arrange multiple circular plots in one page (Figure 7.7). layout(matrix(1:9, 3, 3)) for(i in 1:9) { sectors = 1:8 par(mar = c(0.5, 0.5, 0.5, 0.5)) circos.par(cell.padding = c(0, 0, 0, 0)) circos.initialize(sectors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), track.height = 0.05, bg.col = rand_color(8), bg.border = NA) for(i in 1:20) { se = sample(1:8, 2) circos.link(se[1], runif(2), se[2], runif(2), col = rand_color(1, transparency = 0.4), border = NA) } circos.clear() } Figure 7.7: Arrange multiple circular plots. "],["genomic-introduction.html", "Chapter 8 Introduction 8.1 Input data", " Chapter 8 Introduction Circular visualization is popular in Genomics and related omics fields. It is efficient in revealing associations in high dimensional genomic data. In genomic plots, categories are usually chromosomes and data on x axes are genomic positions, but it can also be any kind of general genomic categories. To make is easy for Genomics analysis, circlize package particularly provides functions which focus on genomic plots. These functions are synonymous to the basic graphic functions but expect special format of input data: circos.genomicTrack(): create a new track and add graphics. circos.genomicPoints(): low-level function, add points. circos.genomicLines(): low-level function, add lines or segments. circos.genomicRect(): low-level function, add rectangles. circos.genomicText(): low-level function, add text. circos.genomicLink(): add links. The genomic functions are implemented by basic circlize functions (e.g. circos.track(), circos.points()), thus, the use of genomic functions can be mixed with the basic circlize functions. 8.1 Input data Genomic data is usually stored as a table where the first three columns define the genomic regions and following columns are values associated with the corresponding regions. Each genomic region is composed by three elements: genomic category (in most case, it is the chromosome), start position on the genomic category and the end position. Such data structure is known as BED format and is broadly used in genomic research. circlize provides a simple function generateRandomBed() which generates random genomic data. Positions are uniformly generated from human genome and the number of regions on chromosomes approximately proportional to the length of chromosomes. In the function, nr and nc control the number of rows and numeric columns that users need. Please note nr are not exactly the same as the number of rows which are returned by the function. fun argument is a self-defined function to generate random values. set.seed(999) bed = generateRandomBed() head(bed) ## chr start end value1 ## 1 chr1 118750 451929 -0.367702502 ## 2 chr1 472114 805024 -0.001764946 ## 3 chr1 807013 914103 -0.668379255 ## 4 chr1 1058915 1081590 0.390291705 ## 5 chr1 1194426 1341960 -1.305901261 ## 6 chr1 1670402 2048723 0.340227447 bed = generateRandomBed(nr = 200, nc = 4) nrow(bed) ## [1] 205 bed = generateRandomBed(nc = 2, fun = function(k) sample(letters, k, replace = TRUE)) head(bed) ## chr start end value1 value2 ## 1 chr1 275067 349212 q e ## 2 chr1 350892 658970 u f ## 3 chr1 674620 875538 y r ## 4 chr1 1053255 1115056 p e ## 5 chr1 1127139 1545066 a s ## 6 chr1 1864092 1973553 x u All genomic functions in circlize expect input variable as a data frame which contains genomic data or a list of data frames which contains genomic data in different conditions. "],["initialize-genomic-plot.html", "Chapter 9 Initialize with genomic data 9.1 Initialize with cytoband data 9.2 Customize chromosome track 9.3 Initialize with general genomic category 9.4 Zooming chromosomes 9.5 Concatenating two genomes", " Chapter 9 Initialize with genomic data circlize is quite flexible to initialize the circular plot not only by chromosomes, but also by any type of general genomic categories. 9.1 Initialize with cytoband data Cytoband data is an ideal data source to initialize genomic plots. It contains length of chromosomes as well as so called “chromosome band” annotation to help to identify positions on chromosomes. 9.1.1 Basic usage If you work on human genome, the most straightforward way is to directly use circos.initializeWithIdeogram() (Figure 9.1). By default, the function creates a track with chromosome name and axes, and a track of ideograms. Although chromosome names added to the plot are pure numeric, actually the internally names have the “chr” index. When you adding more tracks, the chromosome names should also have “chr” index. circos.initializeWithIdeogram() text(0, 0, &quot;default&quot;, cex = 1) Figure 9.1: Initialize genomic plot, default. circos.info() ## All your sectors: ## [1] &quot;chr1&quot; &quot;chr2&quot; &quot;chr3&quot; &quot;chr4&quot; &quot;chr5&quot; &quot;chr6&quot; &quot;chr7&quot; &quot;chr8&quot; &quot;chr9&quot; ## [10] &quot;chr10&quot; &quot;chr11&quot; &quot;chr12&quot; &quot;chr13&quot; &quot;chr14&quot; &quot;chr15&quot; &quot;chr16&quot; &quot;chr17&quot; &quot;chr18&quot; ## [19] &quot;chr19&quot; &quot;chr20&quot; &quot;chr21&quot; &quot;chr22&quot; &quot;chrX&quot; &quot;chrY&quot; ## ## All your tracks: ## [1] 1 2 ## ## Your current sector.index is chrY ## Your current track.index is 2 circos.clear() By default, circos.initializeWithIdeogram() initializes the plot with cytoband data of human genome hg19. Users can also initialize with other species by specifying species argument and it will automatically download cytoband files for corresponding species. circos.initializeWithIdeogram(species = &quot;hg18&quot;) circos.initializeWithIdeogram(species = &quot;mm10&quot;) When you are dealing rare species and there is no cytoband data available yet, circos.initializeWithIdeogram() will try to continue to download the “chromInfo” file form UCSC, which also contains lengths of chromosomes, but of course, there is no ideogram track on the plot. In some cases, when there is no internet connection for downloading or there is no corresponding data avaiable on UCSC yet. You can manually construct a data frame which contains ranges of chromosomes or a file path if it is stored in a file, and sent to circos.initializeWithIdeogram(). cytoband.file = system.file(package = &quot;circlize&quot;, &quot;extdata&quot;, &quot;cytoBand.txt&quot;) circos.initializeWithIdeogram(cytoband.file) cytoband.df = read.table(cytoband.file, colClasses = c(&quot;character&quot;, &quot;numeric&quot;, &quot;numeric&quot;, &quot;character&quot;, &quot;character&quot;), sep = &quot;\\t&quot;) circos.initializeWithIdeogram(cytoband.df) If you read cytoband data directly from file, please explicitly specify colClasses arguments and set the class of position columns as numeric. The reason is since positions are represented as integers, read.table would treat those numbers as integer by default. In initialization of circular plot, circlize needs to calculate the summation of all chromosome lengths. The summation of such large integers would throw error of integer overflow. By default, circos.intializeWithIdeogram() uses all chromosomes which are available in cytoband data to initialize the circular plot. Users can choose a subset of chromosomes by specifying chromosome.index. This argument is also for ordering chromosomes (Figure 9.2). circos.initializeWithIdeogram(chromosome.index = paste0(&quot;chr&quot;, c(3,5,2,8))) text(0, 0, &quot;subset of chromosomes&quot;, cex = 1) Figure 9.2: Initialize genomic plot, subset chromosomes. circos.clear() When there is no cytoband data for the specified species, and when chromInfo data is used instead, there may be many many extra short contigs. chromosome.index can also be useful to remove unnecessary contigs. 9.1.2 Pre-defined tracks After the initialization of the circular plot, circos.initializeWithIdeogram() additionally creates a track where there are genomic axes and chromosome names, and create another track where there is an ideogram (depends on whether cytoband data is available). plotType argument is used to control which type of tracks to add. (figure Figure 9.3). circos.initializeWithIdeogram(plotType = c(&quot;axis&quot;, &quot;labels&quot;)) text(0, 0, &quot;plotType = c(&#39;axis&#39;, &#39;labels&#39;)&quot;, cex = 1) circos.clear() circos.initializeWithIdeogram(plotType = NULL) text(0, 0, &quot;plotType = NULL&quot;, cex = 1) Figure 9.3: Initialize genomic plot, control tracks. circos.clear() 9.1.3 Other general settings Similar as general circular plot, the parameters for the layout can be controlled by circos.par() (Figure 9.4). Do remember when you explicitly set circos.par(), you need to call circos.clear() to finish the plotting. circos.par(&quot;start.degree&quot; = 90) circos.initializeWithIdeogram() circos.clear() text(0, 0, &quot;&#39;start.degree&#39; = 90&quot;, cex = 1) circos.par(&quot;gap.degree&quot; = rep(c(2, 4), 12)) circos.initializeWithIdeogram() circos.clear() text(0, 0, &quot;&#39;gap.degree&#39; = rep(c(2, 4), 12)&quot;, cex = 1) Figure 9.4: Initialize genomic plot, control layout. 9.2 Customize chromosome track By default circos.initializeWithIdeogram() initializes the layout and adds two tracks. When plotType argument is set to NULL, the circular layout is only initialized but nothing is added. This makes it possible for users to completely design their own style of chromosome track. In the following example, we use different colors to represent chromosomes and put chromosome names in the center of each cell (Figure 9.5). set.seed(123) circos.initializeWithIdeogram(plotType = NULL) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { chr = CELL_META$sector.index xlim = CELL_META$xlim ylim = CELL_META$ylim circos.rect(xlim[1], 0, xlim[2], 1, col = rand_color(1)) circos.text(mean(xlim), mean(ylim), chr, cex = 0.7, col = &quot;white&quot;, facing = &quot;inside&quot;, niceFacing = TRUE) }, track.height = 0.15, bg.border = NA) Figure 9.5: Customize chromosome track. circos.clear() 9.3 Initialize with general genomic category Chromosome is just a special case of genomic category. circos.genomicInitialize() can initialize circular layout with any type of genomic categories. In fact, circos.initializeWithIdeogram() is implemented by circos.genomicInitialize(). The input data for circos.genomicInitialize() is also a data frame with at least three columns. The first column is genomic category (for cytoband data, it is chromosome name), and the next two columns are positions in each genomic category. The range in each category will be inferred as the minimum position and the maximum position in corresponding category. In the following example, a circular plot is initialized with three genes. df = data.frame( name = c(&quot;TP53&quot;, &quot;TP63&quot;, &quot;TP73&quot;), start = c(7565097, 189349205, 3569084), end = c(7590856, 189615068, 3652765)) circos.genomicInitialize(df) Note it is not necessary that the record for each gene is only one row. In following example, we plot the transcripts for TP53, TP63 and TP73 in a circular layout (Figure 9.6). tp_family = readRDS(system.file(package = &quot;circlize&quot;, &quot;extdata&quot;, &quot;tp_family_df.rds&quot;)) head(tp_family) ## gene start end transcript exon ## 1 TP53 7565097 7565332 ENST00000413465.2 7 ## 2 TP53 7577499 7577608 ENST00000413465.2 6 ## 3 TP53 7578177 7578289 ENST00000413465.2 5 ## 4 TP53 7578371 7578554 ENST00000413465.2 4 ## 5 TP53 7579312 7579590 ENST00000413465.2 3 ## 6 TP53 7579700 7579721 ENST00000413465.2 2 In the following code, we first create a track which identifies three genes. circos.genomicInitialize(tp_family) circos.track(ylim = c(0, 1), bg.col = c(&quot;#FF000040&quot;, &quot;#00FF0040&quot;, &quot;#0000FF40&quot;), bg.border = NA, track.height = 0.05) Next, we put transcripts one after the other for each gene. It is simply to add lines and rectangles. The usage of circos.genomicTrack() and circos.genomicRect() will be discussed in Chapter 10. n = max(tapply(tp_family$transcript, tp_family$gene, function(x) length(unique(x)))) circos.genomicTrack(tp_family, ylim = c(0.5, n + 0.5), panel.fun = function(region, value, ...) { all_tx = unique(value$transcript) for(i in seq_along(all_tx)) { l = value$transcript == all_tx[i] # for each transcript current_tx_start = min(region[l, 1]) current_tx_end = max(region[l, 2]) circos.lines(c(current_tx_start, current_tx_end), c(n - i + 1, n - i + 1), col = &quot;#CCCCCC&quot;) circos.genomicRect(region[l, , drop = FALSE], ytop = n - i + 1 + 0.4, ybottom = n - i + 1 - 0.4, col = &quot;orange&quot;, border = NA) } }, bg.border = NA, track.height = 0.4) circos.clear() Figure 9.6: Circular representation of alternative transcripts for genes. In Figure 9.6, you may notice the start of axes becomes “0KB” while not the original values. It is just an adjustment of the axes labels to reflect the relative distance to the start of each gene, while the coordinate in the cells are still using the original values. Set tickLabelsStartFromZero to FALSE to recover axes labels to the original values. 9.4 Zooming chromosomes The strategy is the same as introduced in Section 7.1. We first define a function extend_chromosomes() which copy data in subset of chromosomes into the original data frame. extend_chromosomes = function(bed, chromosome, prefix = &quot;zoom_&quot;) { zoom_bed = bed[bed[[1]] %in% chromosome, , drop = FALSE] zoom_bed[[1]] = paste0(prefix, zoom_bed[[1]]) rbind(bed, zoom_bed) } We use read.cytoband() to download and read cytoband data from UCSC. In following, x ranges for normal chromosomes and zoomed chromosomes are normalized separetely. cytoband = read.cytoband() cytoband_df = cytoband$df chromosome = cytoband$chromosome xrange = c(cytoband$chr.len, cytoband$chr.len[c(&quot;chr1&quot;, &quot;chr2&quot;)]) normal_chr_index = 1:24 zoomed_chr_index = 25:26 # normalize in normal chromsomes and zoomed chromosomes separately sector.width = c(xrange[normal_chr_index] / sum(xrange[normal_chr_index]), xrange[zoomed_chr_index] / sum(xrange[zoomed_chr_index])) The extended cytoband data which is in form of a data frame is sent to circos.initializeWithIdeogram(). You can see the ideograms for chromosome 1 and 2 are zoomed (Figure 9.7). circos.par(start.degree = 90) circos.initializeWithIdeogram(extend_chromosomes(cytoband_df, c(&quot;chr1&quot;, &quot;chr2&quot;)), sector.width = sector.width) Add a new track. bed = generateRandomBed(500) circos.genomicTrack(extend_chromosomes(bed, c(&quot;chr1&quot;, &quot;chr2&quot;)), panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.3) }) Add a link from original chromosome to the zoomed chromosome (Figure 9.7). circos.link(&quot;chr1&quot;, get.cell.meta.data(&quot;cell.xlim&quot;, sector.index = &quot;chr1&quot;), &quot;zoom_chr1&quot;, get.cell.meta.data(&quot;cell.xlim&quot;, sector.index = &quot;zoom_chr1&quot;), col = &quot;#00000020&quot;, border = NA) circos.clear() Figure 9.7: Zoom chromosomes. 9.5 Concatenating two genomes There are some scenarios where users want to visualize more than one genomes in the circular plots. This can be done by making “a combined genome”. In the following example, I combine both human and mouse genomes. human_cytoband = read.cytoband(species = &quot;hg19&quot;)$df mouse_cytoband = read.cytoband(species = &quot;mm10&quot;)$df One thing important is since the two genome will be combined, the chromosome names for each genome need to be adjusted. Here I simply add human_/mouse_ prefix. human_cytoband[ ,1] = paste0(&quot;human_&quot;, human_cytoband[, 1]) mouse_cytoband[ ,1] = paste0(&quot;mouse_&quot;, mouse_cytoband[, 1]) Now I can combine the two cytoband data frames into one. cytoband = rbind(human_cytoband, mouse_cytoband) head(cytoband) ## V1 V2 V3 V4 V5 ## 1 human_chr1 0 2300000 p36.33 gneg ## 2 human_chr1 2300000 5400000 p36.32 gpos25 ## 3 human_chr1 5400000 7200000 p36.31 gneg ## 4 human_chr1 7200000 9200000 p36.23 gpos25 ## 5 human_chr1 9200000 12700000 p36.22 gneg ## 6 human_chr1 12700000 16200000 p36.21 gpos50 The combined cytoband is still a valid cytoband data frame, thus, the ideograms can be drawn for the combined genome. Also when I construct the variable chromosome.index, I let human chromosome 1 to be close to mouse chromosome 1 (Figure 9.8. chromosome.index = c(paste0(&quot;human_chr&quot;, c(1:22, &quot;X&quot;, &quot;Y&quot;)), rev(paste0(&quot;mouse_chr&quot;, c(1:19, &quot;X&quot;, &quot;Y&quot;)))) circos.initializeWithIdeogram(cytoband, chromosome.index = chromosome.index) Figure 9.8: Default style of two combined genomes. circos.clear() By default, in the plot there are chromosome names, axes and ideograms. Now for the combined genome, since there are quite a lot of chromosomes, each chromosome will be very short in the plot, which makes it not easy to read the axes and the long chromosome names. In the following improved code, I turn off the chromosome name and the axes. We create a small track to discriminate human chromosomes and mouse chromosomes (by highlight.chromosome()) and I only write the numeric indices (also X and Y) for chromosomes. A gap of 5 degrees is set between human and mouse chromosomes (by circos.par(\"gap.after\")) (Figure 9.9. circos.par(gap.after = c(rep(1, 23), 5, rep(1, 20), 5)) circos.initializeWithIdeogram(cytoband, plotType = NULL, chromosome.index = chromosome.index) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), gsub(&quot;.*chr&quot;, &quot;&quot;, CELL_META$sector.index), cex = 0.6, niceFacing = TRUE) }, track.height = mm_h(1), cell.padding = c(0, 0, 0, 0), bg.border = NA) highlight.chromosome(paste0(&quot;human_chr&quot;, c(1:22, &quot;X&quot;, &quot;Y&quot;)), col = &quot;red&quot;, track.index = 1) highlight.chromosome(paste0(&quot;mouse_chr&quot;, c(1:19, &quot;X&quot;, &quot;Y&quot;)), col = &quot;blue&quot;, track.index = 1) circos.genomicIdeogram(cytoband) Figure 9.9: Improved visualization of the combined genome. circos.clear() In previous example, I demonstrate to create the circular layout for the combined genome with the cytoband data frames. The layout can also be created only by the chromosome ranges, i.e., the length of each chromosome. In the following code, read.chromInfo() can fetch the chromosome range for a specific genome. human_chromInfo = read.chromInfo(species = &quot;hg19&quot;)$df mouse_chromInfo = read.chromInfo(species = &quot;mm10&quot;)$df human_chromInfo[ ,1] = paste0(&quot;human_&quot;, human_chromInfo[, 1]) mouse_chromInfo[ ,1] = paste0(&quot;mouse_&quot;, mouse_chromInfo[, 1]) chromInfo = rbind(human_chromInfo, mouse_chromInfo) # note the levels of the factor controls the chromosome orders in the plot chromInfo[, 1] = factor(chromInfo[ ,1], levels = chromosome.index) head(chromInfo) ## chr start end ## 1 human_chr1 0 249250621 ## 2 human_chr2 0 243199373 ## 3 human_chr3 0 198022430 ## 4 human_chr4 0 191154276 ## 5 human_chr5 0 180915260 ## 6 human_chr6 0 171115067 With the specified chromosome ranges, circos.genomicInitialize() is used to initialize the layout (Figure 9.10. circos.par(gap.after = c(rep(1, 23), 5, rep(1, 20), 5)) circos.genomicInitialize(chromInfo, plotType = NULL) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), gsub(&quot;.*chr&quot;, &quot;&quot;, CELL_META$sector.index), cex = 0.6, niceFacing = TRUE) }, track.height = mm_h(1), cell.padding = c(0, 0, 0, 0), bg.border = NA) highlight.chromosome(paste0(&quot;human_chr&quot;, c(1:22, &quot;X&quot;, &quot;Y&quot;)), col = &quot;red&quot;, track.index = 1) highlight.chromosome(paste0(&quot;mouse_chr&quot;, c(1:19, &quot;X&quot;, &quot;Y&quot;)), col = &quot;blue&quot;, track.index = 1) circos.track(ylim = c(0, 1)) Figure 9.10: Initialize the plot with chromosome ranges. circos.clear() Adding more tracks has no difference to the single-genome plots. The only thing to note is the chromosome names should be properly formatted. In the following code, I create a track of points and add links between human and mouse genomes (Figure 9.11. circos.par(gap.after = c(rep(1, 23), 5, rep(1, 20), 5)) circos.genomicInitialize(chromInfo, plotType = NULL) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), gsub(&quot;.*chr&quot;, &quot;&quot;, CELL_META$sector.index), cex = 0.6, niceFacing = TRUE) }, track.height = mm_h(1), cell.padding = c(0, 0, 0, 0), bg.border = NA) highlight.chromosome(paste0(&quot;human_chr&quot;, c(1:22, &quot;X&quot;, &quot;Y&quot;)), col = &quot;red&quot;, track.index = 1) highlight.chromosome(paste0(&quot;mouse_chr&quot;, c(1:19, &quot;X&quot;, &quot;Y&quot;)), col = &quot;blue&quot;, track.index = 1) circos.genomicIdeogram(cytoband) # a track of points human_df = generateRandomBed(200, species = &quot;hg19&quot;) mouse_df = generateRandomBed(200, species = &quot;mm10&quot;) human_df[ ,1] = paste0(&quot;human_&quot;, human_df[, 1]) mouse_df[ ,1] = paste0(&quot;mouse_&quot;, mouse_df[, 1]) df = rbind(human_df, mouse_df) circos.genomicTrack(df, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, col = rand_color(1), cex = 0.5, ...) }) # links between human and mouse genomes human_mid = data.frame( chr = paste0(&quot;human_chr&quot;, 1:19), mid = round((human_chromInfo[1:19, 2] + human_chromInfo[1:19, 3])/2) ) mouse_mid = data.frame( chr = paste0(&quot;mouse_chr&quot;, 1:19), mid = round((mouse_chromInfo[1:19, 2] + mouse_chromInfo[1:19, 3])/2) ) circos.genomicLink(human_mid, mouse_mid, col = rand_color(19)) circos.clear() text(-0.9, -0.8, &quot;Human\\ngenome&quot;) text(0.9, 0.8, &quot;Mouse\\ngenome&quot;) Figure 9.11: The combined genome with more tracks. "],["genomic-plotting-region.html", "Chapter 10 Create plotting regions for genomic data 10.1 Points 10.2 Lines 10.3 Text 10.4 Rectangles 10.5 Links 10.6 Mixed use of general circlize functions", " Chapter 10 Create plotting regions for genomic data Tracks are created and graphics are added by circos.genomicTrackPlotRegions(), or the short version circos.genomicTrack(). In following examples, chromosome will be used as the genomic category, and we assume data is simply a data frame in BED format (where the first column is the chromosome name, the second and third column are start and end positions, and the following columns are associated values). For more complex form of data and behaviour of the functions, we will introduce in Chapter 11. Similar as circos.track(), circos.genomicTrack() also accepts a self- defined function panel.fun which is applied in every cell but with different form. circos.genomicTrackPlotRegion(data, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, ...) }) Inside panel.fun, users can use low-level graphic functions to add basic graphics in each cell. panel.fun expects two arguments region and value which are automatically processed and passed from circos.genomicTrack(). region is a two-column data frame which only contains start position and end position in the current chromosome. value is also a data frame which contains other columns (start for the fourth column, if it exists). Thus, basically, region can be thought as values on x axes and value as values on y axes. There should be a third arguments ... which is mandatory and is used to pass user-invisible variables to inner functions and make magics (explained in Chapter 11). So whenever you use panel.fun in circos.genomicTrack(), please add it to the end of your function. Following code demonstrates the values for region and value when used inside panel.fun. bed = generateRandomBed(nc = 2) head(bed, n = 2) ## chr start end value1 value2 ## 1 chr1 55659 272460 0.1481202 -0.9773213 ## 2 chr1 994899 1136003 -1.1922246 0.3737273 circos.initializeWithIdeogram(plotType = NULL) circos.genomicTrackPlotRegion(bed, panel.fun = function(region, value, ...) { if(CELL_META$sector.index == &quot;chr1&quot;) { print(head(region, n = 2)) print(head(value, n = 2)) } }) ## start end ## 1 55659 272460 ## 2 994899 1136003 ## value1 value2 ## 1 0.1481202 -0.9773213 ## 2 -1.1922246 0.3737273 Since circos.genomicTrack() creates a new track, it needs values to calculate data ranges on y direction. Users can either specify the index of numeric columns in data by numeric.column (named index or numeric index, it can also be a vector with more than one columns) or directly set ylim. If none of them are set, the function will try to look for all numeric columns in data (of course, excluding the first three columns), and set them as numeric.column. circos.genomicTrackPlotRegion(data, ylim = c(0, 1), panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, ...) }) circos.genomicTrackPlotRegion(data, numeric.column = c(&quot;value1&quot;, &quot;value2&quot;), panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, ...) }) Since genomic functions are implemented by basic circlize functions, you can use circos.info() anywhere to get information of sectors and tracks. As you already see in previous examples, circlize also provides low-level graphic functions specifically designed for genomic data. They are all implemented by the corresponding normal circlize functions, but needs input variables with special format. In this chapter, we introduce the basic usage of circos.genomicTrack() and low-level circos.genomic*(). In Chapter 11, we will introduce more usages of these functions, which are especially designed for genomic regions measured at multiple conditions. Example plots are shown together in Chapter 11. 10.1 Points Usage of circos.genomicPoints() is similar as circos.points(). circos.genomicPoints() expects a two-column data frame which contains genomic regions and a data frame containing corresponding values. Points are always drawn at the middle of each region. The data column of the y values for plotting should be specified by numeric.column. If numeric.column has length larger than one, all the specified columns will be used for adding points. If the function is called inside circos.genomicTrack() and users have been already set numeric.column in circos.genomicTrack(), proper value of numeric.column will be passed to circos.genomicPoints() through ... in panel.fun, which means, you must add ... as the final argument in circos.genomicPoints() to get such information. If numeric.column is not set in both places, circos.genomicPoints() will use all numeric columns detected in value. Note here numeric.column is measured in value while numeric.column in circos.genomicTrack() is measured in the complete data frame. There is a difference of 3 for the column index! When numeric.column is passed to circos.genomicPoints() internally, 3 is subtracted automatically. If you use character index instead of numeric index, you do not need to worry about it. Possible usages of circos.genomicPoints() are as follows. circos.genomicPoints(region, value, numeric.column = c(1, 2)) circos.genomicPoints(region, value, cex, pch) circos.genomicPoints(region, value, sector.index, track.index) circos.genomicTrack(data, numeric.column = 4, panel.fun = function(region, value, ...) { # numeric.column is automatically passed to `circos.genomicPoints()` circos.genomicPoints(region, value, ...) }) If there is only one numeric column, graphical parameters such as pch, cex can be of length one or number of rows of region. If there are more than one numeric columns specified, points for each numeric column will be added iteratively, and the graphical parameters should be either length one or number of numeric columns specified. circos.genomicPoints() is simply implemented by circos.points(). The basic idea of the implementation is shown as following code, so, if you don’t like the circos.genomic*() functions, it would not be difficult to directly use the circos.*() functions. circos.genomicPoints = function(region, value, numeric.column = 1, ...) { x = (region[[2]] + region[[1]])/2 for(i in numeric.column) { y = value[[i]] circos.points(x, y, ...) } } 10.2 Lines circos.genomicLines() is similar as circos.lines(). The setting of graphical parameters is similar as circos.genomicPoints(). circos.genomicLines(region, value, ...) circos.genomicLines(region, value, numeric.column = c(1, 2)) circos.genomicLines(region, value, area, baseline, border) circos.genomicLines(region, value, sector.index, track.index) circlize additionally provides a new option segment for lty by which each genomic regions represent as ‘horizontal’ lines at y positions (see Figure 11.2, track H). circos.genomicLines(region, value, lwd, lty = &quot;segment&quot;) 10.3 Text For circos.genomicText(), the position of text can be specified either by numeric.column or a separated vector y. The labels of text can be specified either by labels.column or a vector labels. circos.genomicText(region, value, ...) circos.genomicText(region, value, y = 1, labels) circos.genomicText(region, value, numeric.column, labels.column) circos.genomicText(region, value, facing, niceFacing, adj) circos.genomicText(region, value, sector.index, track.index) 10.4 Rectangles For circos.genomicRect(), Since the left and right of the rectangles are already determined by the start and end of the genomic regions, we only need to set the positions of top and bottom of the rectangles by specifying ytop, ybottom or ytop.column, ybottom.column. circos.genomicRect(region, value, ytop = 1, ybottom = 0) circos.genomicRect(region, value, ytop.column = 2, ybottom = 0) circos.genomicRect(region, value, col, border) 10.5 Links circos.genomicLink() expects two data frames and it adds links from genomic regions in the first data frame to corresponding genomic regions in the second data frame. All additional arguments are passed to circos.link(). set.seed(123) bed1 = generateRandomBed(nr = 100) bed1 = bed1[sample(nrow(bed1), 20), ] bed2 = generateRandomBed(nr = 100) bed2 = bed2[sample(nrow(bed2), 20), ] circos.initializeWithIdeogram() circos.genomicLink(bed1, bed2, col = rand_color(nrow(bed1), transparency = 0.5), border = NA) Figure 10.1: Add links from two sets of genomic regions. circos.clear() 10.6 Mixed use of general circlize functions panel.fun is applied on each cell, which means, besides genomic graphic functions, you can also use general circlize functions to add more graphics. For example, some horizontal lines and texts are added to each cell and axes are put on top of each cell. circos.genomicTrack(bed, ylim = c(-1, 1), panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, ...) for(h in c(-1, -0.5, 0, 0.5, 1)) { circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = &quot;grey&quot;) } circos.text(x, y, labels) circos.axis(&quot;top&quot;) }) "],["modes-of-input.html", "Chapter 11 modes for circos.genomicTrack() 11.1 Normal mode 11.2 Stack mode 11.3 Applications", " Chapter 11 modes for circos.genomicTrack() The behaviour of circos.genomicTrack() and panel.fun will be different according to different input data (e.g. is it a simple data frame or a list of data frames? If it is a data frame, how many numeric columns it has?) and different settings. 11.1 Normal mode 11.1.1 Input is a data frame If input data is a data frame in BED format, region in panel.fun would be a data frame containing start position and end position in the current chromosome which is extracted from data. value is also a data frame which contains columns in data excluding the first three columns. Index of proper numeric columns will be passed by ... if it is set in circos.genomicTrack(). If users want to use such information, they need to pass ... to low-level genomic function such as circos.genoimcPoints() as well. If there are more than one numeric columns, graphics are added for each column repeatedly (with same genomic positions). data = generateRandomBed(nc = 2) circos.genomicTrack(data, numeric.column = 4, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, ...) circos.genomicPoints(region, value) # 1st column in `value` while 4th column in `data` circos.genomicPoints(region, value, numeric.column = 1) }) 11.1.2 Input is a list of data frames If input data is a list of data frames, panel.fun is applied on each data frame iteratively to the current cell. Under such condition, region and value will contain corresponding data in the current data frame and in the current chromosome. The index for the current data frame can be get by getI(...). Note getI(...) can only be used inside panel.fun and ... argument is mandatory. When numeric.column is specified in circos.genomicTrack(), the length of numeric.column can only be one or the number of data frames, which means, there is only one numeric column that will be used in each data frame. If it is not specified, the first numeric column in each data frame is used. bed_list = list(generateRandomBed(), generateRandomBed()) circos.genomicTrack(bed_list, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, col = i, ...) }) # column 4 in the first bed and column 5 in the second bed circos.genomicTrack(bed_list, numeric.column = c(4, 5), panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, col = i, ...) }) 11.2 Stack mode circos.genomicTrack() also supports a stack mode by setting stack = TRUE. Under stack mode, ylim is re-defined inside the function and the y-axis is splitted into several bins with equal height and graphics are put onto “horizontal” bins (with position y = 1, 2, ...). 11.2.1 Input is a data frame Under stack mode, when input data is a single data frame containing one or more numeric columns, each numeric column defined in numeric.column will be treated as a single unit (recall that when numeric.column is not specified, all numeric columns are used). ylim is re-defined to c(0.5, n+0.5) in which n is number of numeric columns specified. panel.fun is applied iteratively on each numeric column and add graphics to the horizontal line y = i. In this case, actually value in e.g. circos.genomicPoints() doesn’t used for mapping the y positions, while replaced with y = i internally. In each iteration, in panel.fun, region is still the genomic regions in current chromosome, but value only contains current numeric column plus all non-numeric columns. The value of the index of “current” numeric column can be obtained by getI(...). data = generateRandomBed(nc = 2) circos.genomicTrack(data, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, col = i, ...) }) 11.2.2 Input is a list of data frames When input data is a list of data frames, each data frame will be treated as a single unit. ylim is re-defined to c(0.5, n+0.5) in which n is the number of data frames. panel.fun will be applied iteratively on each data frame. In each iteration, in panel.fun, region is still the genomic regions in current chromosome, and value contains columns in current data frame excluding the first three columns. Graphics by low-level genomic functions will be added on the `horizontal’ bins. bed_list = list(generateRandomBed(), generateRandomBed()) circos.genomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, ...) }) Under stack mode, if using a data frame with multiple numeric columns, graphics on all horizontal bins share the same genomic positions while if using a list of data frames, the genomic positions can be different. 11.3 Applications In this section, we will show several real examples of adding genomic graphics under different modes. Again, if you are not happy with these functionalities, you can simply re-implement your plot with the basic circlize functions. 11.3.1 Points To make plots more clear to look at, we only add graphics in the first quarter of the circle and initialize the plot only with chromosome 1. set.seed(999) circos.par(&quot;track.height&quot; = 0.1, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270) circos.initializeWithIdeogram(chromosome.index = &quot;chr1&quot;, plotType = NULL) In the example figure (Figure 11.1) below, each track contains points under different modes. In track A, it is the most normal way to add points. Here bed only contains one numeric column and points are added at the middle points of regions. bed = generateRandomBed(nr = 300) circos.genomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.5, ...) }) In track B, if it is specified as stack mode, points are added in a horizontal line (or visually, a circular line). circos.genomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.5,...) i = getI(...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = &quot;#00000040&quot;) }) In track C, the input data is a list of two data frames. panel.fun is applied iterately on each data frame. The index of “current” index can be obtained by getI(...). bed1 = generateRandomBed(nr = 300) bed2 = generateRandomBed(nr = 300) bed_list = list(bed1, bed2) circos.genomicTrack(bed_list, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...) }) In track D, the list of data frames is plotted under stack mode. Graphics corresponding to each data frame are added to a horizontal line. circos.genomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = &quot;#00000040&quot;) }) In track E, the data frame has four numeric columns. Under normal mode, all the four columns are used with the same genomic coordinates. bed = generateRandomBed(nr = 300, nc = 4) circos.genomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = 1:4, ...) }) In track F, the data frame has four columns but is plotted under stack mode. Graphics for each column are added to a horizontal line. Current column can be obtained by getI(...). Note here value in panel.fun is a data frame with only one column (which is the current numeric column). bed = generateRandomBed(nr = 300, nc = 4) circos.genomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = &quot;#00000040&quot;) }) circos.clear() Figure 11.1: Add points under different modes. 11.3.2 Lines Similar as previous figure, only the first quarter in the circle is visualized. Examples are shown in Figure 11.2. circos.par(&quot;track.height&quot; = 0.08, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270, cell.padding = c(0, 0, 0, 0)) circos.initializeWithIdeogram(chromosome.index = &quot;chr1&quot;, plotType = NULL) In track A, it is the most simple way to add lines. Middle points of regions are used as the values on x-axes. bed = generateRandomBed(nr = 500) circos.genomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value) }) circos.genomicLines() is implemented by circos.lines(), thus, arguments supported in circos.lines() can also be in circos.genomicLines(). In track B, the area under the line is filled with color and in track C, type of the line is set to h. circos.genomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, area = TRUE) }) circos.genomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, type = &quot;h&quot;) }) In track D, the input is a list of data frames. panel.fun is applied to each data frame iterately. bed1 = generateRandomBed(nr = 500) bed2 = generateRandomBed(nr = 500) bed_list = list(bed1, bed2) circos.genomicTrack(bed_list, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) In track E, the input is a list of data frames and is drawn under stack mode. Each genomic region is drawn as a horizontal segment and is put on a horizontal line where the width of the segment corresponds to the width of the genomc region. Under stack mode, for circos.genomicLines(), type of lines is only restricted to segments. circos.genomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) In track F, the input is a data frame with four numeric columns. Each column is drawn under the normal mode where the same genomic coordinates are shared. bed = generateRandomBed(nr = 500, nc = 4) circos.genomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, col = 1:4, ...) }) In track G, the data frame with four numeric columns are drawn under stack mode. All the four columns are drawn to four horizontal lines. bed = generateRandomBed(nr = 500, nc = 4) circos.genomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) In track H, we specify type to segment and set different colors for segments. Note each segment is located at the y position defined in the numeric column. bed = generateRandomBed(nr = 200) circos.genomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, type = &quot;segment&quot;, lwd = 2, col = rand_color(nrow(region)), ...) }) circos.clear() Figure 11.2: Add lines under different modes. 11.3.3 Rectangles Again, only the first quarter of the circle is initialized. For rectangles, the filled colors are always used to represent numeric values. Here we define a color mapping function col_fun to map values to colors. Examples are in Figure 11.3. circos.par(&quot;track.height&quot; = 0.15, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270) circos.initializeWithIdeogram(chromosome.index = &quot;chr1&quot;, plotType = NULL) col_fun = colorRamp2(breaks = c(-1, 0, 1), colors = c(&quot;green&quot;, &quot;black&quot;, &quot;red&quot;)) To draw heatmaps, you probably want to use the stack mode. In track A, bed has four numeric columns and stack mode is used to arrange the heatmap. You can see rectangles are stacked for a certain genomic region. bed = generateRandomBed(nr = 100, nc = 4) circos.genomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { circos.genomicRect(region, value, col = col_fun(value[[1]]), border = NA, ...) }) In track B, the input is a list of data frames. Under stack mode, each data frame is added to a horizontal line. Since genomic positions for different data frames can be different, you may see in the figure, positions for the two sets of rectangles are different. Under stack mode, by default, the height of rectangles is internally set to make them completely fill the cell in the vertical direction. ytop and ybottom can be used to adjust the height of rectangles. Note each line of rectangles is at y = i and the default height of rectangles are 1. bed1 = generateRandomBed(nr = 100) bed2 = generateRandomBed(nr = 100) bed_list = list(bed1, bed2) circos.genomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicRect(region, value, ytop = i + 0.3, ybottom = i - 0.3, col = col_fun(value[[1]]), ...) }) In track C, we implement same graphics as in track B, but with the normal mode. Under stack mode, data range on y axes and positions of rectangles are adjusted internally. Here we explicitly adjust it under the normal mode. circos.genomicTrack(bed_list, ylim = c(0.5, 2.5), panel.fun = function(region, value, ...) { i = getI(...) circos.genomicRect(region, value, ytop = i + 0.3, ybottom = i - 0.3, col = col_fun(value[[1]]), ...) }) In track D, rectangles are used to make barplots. We specify the position of the top of bars by ytop.column (1 means the first column in value). bed = generateRandomBed(nr = 200) circos.genomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicRect(region, value, ytop.column = 1, ybottom = 0, col = ifelse(value[[1]] &gt; 0, &quot;red&quot;, &quot;green&quot;), ...) circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = &quot;#00000040&quot;) }) circos.clear() Figure 11.3: Add rectangles under different modes. "],["high-level-genomic-functions.html", "Chapter 12 High-level genomic functions 12.1 Ideograms 12.2 Heatmaps 12.3 Labels 12.4 Genomic axes 12.5 Genomic density and Rainfall plot", " Chapter 12 High-level genomic functions In this chapter, several high-level functions which create tracks are introduced. 12.1 Ideograms circos.initializeWithIdeogram() initializes the circular plot and adds ideogram track if the cytoband data is available. Actually, the ideograms are drawn by circos.genomicIdeogram(). circos.genomicIdeogram() creates a small track of ideograms and can be used anywhere in the circle. By default it adds ideograms for human genome hg19 (Figure 12.1). circos.initializeWithIdeogram(plotType = c(&quot;labels&quot;, &quot;axis&quot;)) circos.track(ylim = c(0, 1)) circos.genomicIdeogram() # put ideogram as the third track circos.genomicIdeogram(track.height = 0.2) Figure 12.1: Circular ideograms. 12.2 Heatmaps Matrix which corresponds to genomic regions can be visualized as heatmaps. Heatmaps completely fill the track and there are connection lines connecting heatmaps and original positions in the genome. circos.genomicHeatmap() draws connection lines and heatmaps as two tracks and combines them as an integrated track. Generally, all numeric columns (excluding the first three columns) in the input data frame are used to make the heatmap. Columns can also be specified by numeric.column which is either an numeric vector or a character vector. Colors can be specfied as a color matrix or a color mapping function generated by colorRamp2(). The height of the connection line track and the heatmap track can be set by connection_height and heatmap_height arguments. Also parameters for the styles of lines and rectangle borders can be adjusted, please check the help page of circos.genomicHeatmap(). circos.initializeWithIdeogram() bed = generateRandomBed(nr = 100, nc = 4) col_fun = colorRamp2(c(-1, 0, 1), c(&quot;green&quot;, &quot;black&quot;, &quot;red&quot;)) circos.genomicHeatmap(bed, col = col_fun, side = &quot;inside&quot;, border = &quot;white&quot;) circos.clear() In the left figure in Figure 12.2, the heatmaps are put inside the normal genomic track. Heatmaps are also be put outside the normal genomic track by setting side = \"outside\" (Figure 12.2, right). circos.initializeWithIdeogram(plotType = NULL) circos.genomicHeatmap(bed, col = col_fun, side = &quot;outside&quot;, line_col = as.numeric(factor(bed[[1]]))) circos.genomicIdeogram() circos.clear() Figure 12.2: Genomic heamtaps. 12.3 Labels circos.genomicLabels() adds text labels for regions that are specified. Positions of labels are automatically adjusted so that they do not overlap to each other. Similar as circos.genomicHeatmap(), circos.genomicLabels() also creates two tracks where one for the connection lines and one for the labels. You can set the height of the labels track to be the maximum width of labels by labels_height = max(strwidth(labels)). padding argument controls the gap between two neighbouring labels. circos.initializeWithIdeogram() bed = generateRandomBed(nr = 50, fun = function(k) sample(letters, k, replace = TRUE)) bed[1, 4] = &quot;aaaaa&quot; circos.genomicLabels(bed, labels.column = 4, side = &quot;inside&quot;) circos.clear() Similarlly, labels can be put outside of the normal genomic track (Figure 12.3 right). circos.initializeWithIdeogram(plotType = NULL) circos.genomicLabels(bed, labels.column = 4, side = &quot;outside&quot;, col = as.numeric(factor(bed[[1]])), line_col = as.numeric(factor(bed[[1]]))) circos.genomicIdeogram() circos.clear() Figure 12.3: Genomic labels. 12.4 Genomic axes The genomic axes are not really high-level graphics, but it is better to also introduce here. For circos.initializeWithIdeogram(), by default it draws axes with tick labels properly formatted. The axes are internally implemented by circos.genomicAxis() and it can be used to add genomic axes at any track (Figure 12.4). circos.initializeWithIdeogram(plotType = NULL) circos.genomicIdeogram() # still work on the ideogram track circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { circos.genomicAxis(h = &quot;top&quot;) }) circos.track(ylim = c(0, 1), track.height = 0.1) circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { circos.genomicAxis(h = &quot;bottom&quot;, direction = &quot;inside&quot;) }) Figure 12.4: Add genomic axes. circos.clear() 12.5 Genomic density and Rainfall plot Rainfall plots are used to visualize the distribution of genomic regions in the genome. Rainfall plots are particularly useful to identify clusters of regions. In the rainfall plot, each dot represents a region. The x-axis corresponds to the genomic coordinate, and the y-axis corresponds to the minimal distance (log10 transformed) of the region to its two neighbouring regions. A cluster of regions will appear as a “rainfall” in the plot. circos.genomicRainfall() calculates neighbouring distance for each region and draw as points on the plot. Since circos.genomicRainfall() generates data on y-direction (log10(distance)), it is actually a high-level function which creates a new track. The input data can be a single data frame or a list of data frames. circos.genoimcRainfall(bed) circos.genoimcRainfall(bed_list, col = c(&quot;red&quot;, &quot;green&quot;)) However, if the amount of regions in a cluster is high, dots will overlap, and direct assessment of the number and density of regions in the cluster will be impossible. To overcome this limitation, additional tracks are added which visualize the genomic density of regions (defined as the fraction of a genomic window that is covered by genomic regions). circos.genomicDensity() calculates how much a genomic window is covered by regions in bed. It is also a high-level function and creates a new track. The input data can be a single data frame or a list of data frames. circos.genomicDensity(bed) circos.genomicDensity(bed, baseline = 0) circos.genomicDensity(bed, window.size = 1e6) circos.genomicDensity(bedlist, col = c(&quot;#FF000080&quot;, &quot;#0000FF80&quot;)) Following example makes a rainfall plot for differentially methylated regions (DMR) and their genomic densities. In the plot, red corresponds to hyper-methylated DMRs (gain of methylation) and blue corresponds to hypo-methylated DMRs (loss of methylation). You may see how the combination of rainfall track and genomic density track helps to get a more precise inference of the distribution of DMRs on genome (Figure 12.5). load(system.file(package = &quot;circlize&quot;, &quot;extdata&quot;, &quot;DMR.RData&quot;)) circos.initializeWithIdeogram(chromosome.index = paste0(&quot;chr&quot;, 1:22)) bed_list = list(DMR_hyper, DMR_hypo) circos.genomicRainfall(bed_list, pch = 16, cex = 0.4, col = c(&quot;#FF000080&quot;, &quot;#0000FF80&quot;)) circos.genomicDensity(DMR_hyper, col = c(&quot;#FF000080&quot;), track.height = 0.1) circos.genomicDensity(DMR_hypo, col = c(&quot;#0000FF80&quot;), track.height = 0.1) Figure 12.5: Genomic rainfall plot and densities. circos.clear() circos.genomicDensity() also supports to calculate the overlap as the number of the regions that overlap to each window by setting count_by = \"number\". circos.initializeWithIdeogram(chromosome.index = paste0(&quot;chr&quot;, 1:22)) circos.genomicDensity(DMR_hyper, col = c(&quot;#FF000080&quot;), track.height = 0.1) circos.genomicDensity(DMR_hyper, col = c(&quot;#FF000080&quot;), count_by = &quot;number&quot;, track.height = 0.1) Figure 12.6: Genomic densities. circos.clear() Internally, rainfallTransform() and genomicDensity() are used to the neighbrouing distance and the genomic density values. head(rainfallTransform(DMR_hyper)) ## chr start end dist ## 70 chr1 933445 934443 35323 ## 104 chr1 969766 970362 4909 ## 105 chr1 975271 976767 4909 ## 154 chr1 1108819 1109923 31522 ## 155 chr1 1141445 1142405 31522 ## 157 chr1 1181550 1182782 39145 head(genomicDensity(DMR_hyper, window.size = 1e6)) ## chr start end value ## 1 chr1 1 1000000 0.003093 ## 2 chr1 500001 1500000 0.007592 ## 3 chr1 1000001 2000000 0.008848 ## 4 chr1 1500001 2500000 0.010155 ## 5 chr1 2000001 3000000 0.011674 ## 6 chr1 2500001 3500000 0.007783 "],["nested-zooming.html", "Chapter 13 Nested zooming 13.1 Basic idea 13.2 Visualization of DMRs from tagmentation-based WGBS", " Chapter 13 Nested zooming 13.1 Basic idea In Section 7.1 we introduced how to zoom sectors to the same circle in the same track. This works fine if there are only a few regions that need to be zoomed. However, when the regions that need to be zoomed is too many, the method will not work efficiently. In this chapter, we introduce another zooming method which puts zoomed regions in a different circular plot. To illustrate the basic idea, we first generate a random data set. set.seed(123) df = data.frame(cate = sample(letters[1:8], 400, replace = TRUE), x = runif(400), y = runif(400), stringsAsFactors = FALSE) df = df[order(df[[1]], df[[2]]), ] rownames(df) = NULL df$interval_x = as.character(cut(df$x, c(0, 0.2, 0.4, 0.6, 0.8, 1.0))) df$name = paste(df$cate, df$interval_x, sep = &quot;:&quot;) df$start = as.numeric(gsub(&quot;^\\\\((\\\\d(\\\\.\\\\d)?).*(\\\\d(\\\\.\\\\d)?)]&quot;, &quot;\\\\1&quot;, df$interval_x)) df$end = as.numeric(gsub(&quot;^\\\\((\\\\d(\\\\.\\\\d)?),(\\\\d(\\\\.\\\\d)?)]$&quot;, &quot;\\\\3&quot;, df$interval_x)) nm = sample(unique(df$name), 20) df2 = df[df$name %in% nm, ] correspondance = unique(df2[, c(&quot;cate&quot;, &quot;start&quot;, &quot;end&quot;, &quot;name&quot;, &quot;start&quot;, &quot;end&quot;)]) zoom_sector = unique(df2[, c(&quot;name&quot;, &quot;start&quot;, &quot;end&quot;, &quot;cate&quot;)]) zoom_data = df2[, c(&quot;name&quot;, &quot;x&quot;, &quot;y&quot;)] data = df[, 1:3] sector = data.frame(cate = letters[1:8], start = 0, end = 1, stringsAsFactors = FALSE) sector_col = structure(rand_color(8, transparency = 0.5), names = letters[1:8]) Following variables are used for downstream visualization. sector contains sector names and coordinates at the x direction: head(sector, n = 4) ## cate start end ## 1 a 0 1 ## 2 b 0 1 ## 3 c 0 1 ## 4 d 0 1 data contains data points for a track. head(data, n = 4) ## cate x y ## 1 a 0.02314449 0.2170480 ## 2 a 0.03978064 0.8062479 ## 3 a 0.06893260 0.6284048 ## 4 a 0.07997291 0.5835629 In sector, we randomly sampled several intervals which will be used for zooming. The zoomed intervals are stored in zoom_sector. In the zooming track, each interval is treated as an independent sector, thus, the name for each zoomed interval uses combination of the original sector name and the interval itself, just for easy reading. head(zoom_sector, n = 4) ## name start end cate ## 17 a:(0.4,0.6] 0.4 0.6 a ## 48 a:(0.8,1] 0.8 1.0 a ## 57 b:(0,0.2] 0.0 0.2 b ## 76 b:(0.4,0.6] 0.4 0.6 b And the subset of data which are in the zoomed intervals. head(zoom_data, n = 4) ## name x y ## 17 a:(0.4,0.6] 0.4072693 0.3972460 ## 18 a:(0.4,0.6] 0.4186692 0.2021846 ## 19 a:(0.4,0.6] 0.4481431 0.3554347 ## 20 a:(0.4,0.6] 0.4597852 0.6696035 The correspondance between the original sectors and the zoomed intervals are in correspondance. The value is a data frame with six columns. The value is the position of the intervals in the second circular plot in the first plot. head(correspondance, n = 4) ## cate start end name start.1 end.1 ## 17 a 0.4 0.6 a:(0.4,0.6] 0.4 0.6 ## 48 a 0.8 1.0 a:(0.8,1] 0.8 1.0 ## 57 b 0.0 0.2 b:(0,0.2] 0.0 0.2 ## 76 b 0.4 0.6 b:(0.4,0.6] 0.4 0.6 The zooming is actually composed of two circulat plots where one for the original track and one for the zoomed intervals. There is an additional connection track which identifies which intervals that are zoomed belong to which sector. The circos.nested() function in circlize puts the two circular plots together, arranges them and automatically draws the connection lines. To define “the circular plot”, the code for generating the plot needs to be wrapped into a function. f1 = function() { circos.par(gap.degree = 10) circos.initialize(sector[, 1], xlim = sector[, 2:3]) circos.track(data[[1]], x = data[[2]], y = data[[3]], ylim = c(0, 1), panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5, col = &quot;red&quot;) }) } f2 = function() { circos.par(gap.degree = 2, cell.padding = c(0, 0, 0, 0)) circos.initialize(zoom_sector[[1]], xlim = as.matrix(zoom_sector[, 2:3])) circos.track(zoom_data[[1]], x = zoom_data[[2]], y = zoom_data[[3]], panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5) }) } In above, f1() is the code for generating the original plot and f2() is the code for generating the zoomed plot. They can be executed independently. To combine the two plots, simply put f1(), f2() and corresponance to circos.nested() (Figure 13.1). circos.nested(f1, f2, correspondance) Figure 13.1: Nested zooming between two circular plots. In the plot, the zoomed circle is put inside the original circle and the start degree for the second plot is automatically adjusted. Zoomed circle can also be put outside by swtiching f1() and f2(). Actually, for circos.nested(), It doesn’t care which one is zoomed or not, they are just two circular plots and a correspondance (Figure 13.2). circos.nested(f2, f1, correspondance[, c(4:6, 1:3)]) Figure 13.2: Nested zooming between two circular plots, zoomed plot is put outside. There are some points that need to be noted while doing nested zoomings: It can only be applied to the full circle. If canvas.xlim and canvas.ylim are adjusted in the first plot, same value should be set to the second plot. By default the start degree of the second plot is automatically adjusted to make the difference between the original positions and zoomed sectors to a minimal. However, users can also manually adjusted the start degree for the second plot by setting circos.par(\"start.degree\" = ...) and adjust_start_degree must be set to TRUE in circos.nested(). Since the function needs to know some information for the two circular plots, do not put circos.clear() at the end of each plot. They will be added internally. f1() and f2() are just normal code for implementing circular plot. There is no problem to make it more complex (Figure 13.3). sector_col = structure(rand_color(8, transparency = 0.5), names = letters[1:8]) f1 = function() { circos.par(gap.degree = 10) circos.initialize(sector[, 1], xlim = sector[, 2:3]) circos.track(data[[1]], x = data[[2]], y = data[[3]], ylim = c(0, 1), panel.fun = function(x, y) { l = correspondance[[1]] == CELL_META$sector.index if(sum(l)) { for(i in which(l)) { circos.rect(correspondance[i, 2], CELL_META$cell.ylim[1], correspondance[i, 3], CELL_META$cell.ylim[2], col = sector_col[CELL_META$sector.index], border = sector_col[CELL_META$sector.index]) } } circos.points(x, y, pch = 16, cex = 0.5) circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), CELL_META$sector.index, niceFacing = TRUE, adj = c(0.5, 0)) }) } f2 = function() { circos.par(gap.degree = 2, cell.padding = c(0, 0, 0, 0)) circos.initialize(zoom_sector[[1]], xlim = as.matrix(zoom_sector[, 2:3])) circos.track(zoom_data[[1]], x = zoom_data[[2]], y = zoom_data[[3]], panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5) }, bg.col = sector_col[zoom_sector$cate], track.margin = c(0, 0)) } circos.nested(f1, f2, correspondance, connection_col = sector_col[correspondance[[1]]]) Figure 13.3: Nested zooming between two circular plots, slightly complex plots. 13.2 Visualization of DMRs from tagmentation-based WGBS Tagmentation-based whole-genome bisulfite sequencing (T-WGBS) is a technology which can examine only a minor fraction of methylome of interest. In this section, we demonstrate how to visualize DMRs which are detected from T-WGBS data in a circular plot by circlize package. In the example data loaded, tagments contains regions which are sequenced, DMR1 contains DMRs for one patient detectd in tagment regions. Correspondance between tagment regions and original genome is stored in correspondance. load(system.file(package = &quot;circlize&quot;, &quot;extdata&quot;, &quot;tagments_WGBS_DMR.RData&quot;)) head(tagments, n = 4) ## tagments start end chr ## 1 chr1-44876009-45016546 44876009 45016546 chr1 ## 2 chr1-90460304-90761641 90460304 90761641 chr1 ## 3 chr1-211666507-211692757 211666507 211692757 chr1 ## 4 chr2-46387184-46477385 46387184 46477385 chr2 head(DMR1, n = 4) ## chr start end methDiff ## 1 chr1-44876009-45016546 44894352 44894643 -0.2812889 ## 2 chr1-44876009-45016546 44902069 44902966 -0.3331170 ## 3 chr1-90460304-90761641 90535428 90536046 -0.3550701 ## 4 chr1-90460304-90761641 90546991 90547262 -0.4310808 head(correspondance, n = 4) ## chr start end tagments start.1 end.1 ## 1 chr1 44876009 45016546 chr1-44876009-45016546 44876009 45016546 ## 2 chr1 90460304 90761641 chr1-90460304-90761641 90460304 90761641 ## 3 chr1 211666507 211692757 chr1-211666507-211692757 211666507 211692757 ## 4 chr2 46387184 46477385 chr2-46387184-46477385 46387184 46477385 In Figure 13.4, the tagment regions are actually zoomed from the genome. In following code, f1() only makes a circular plot with whole genome and f2() makes circular plot for the tagment regions. chr_bg_color = rand_color(22, transparency = 0.8) names(chr_bg_color) = paste0(&quot;chr&quot;, 1:22) f1 = function() { circos.par(gap.after = 2, start.degree = 90) circos.initializeWithIdeogram(chromosome.index = paste0(&quot;chr&quot;, 1:22), plotType = c(&quot;ideogram&quot;, &quot;labels&quot;), ideogram.height = 0.03) } f2 = function() { circos.par(cell.padding = c(0, 0, 0, 0), gap.after = c(rep(1, nrow(tagments)-1), 10)) circos.genomicInitialize(tagments, plotType = NULL) circos.genomicTrack(DMR1, ylim = c(-0.6, 0.6), panel.fun = function(region, value, ...) { for(h in seq(-0.6, 0.6, by = 0.2)) { circos.lines(CELL_META$cell.xlim, c(h, h), lty = 3, col = &quot;#AAAAAA&quot;) } circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 3, col = &quot;#888888&quot;) circos.genomicPoints(region, value, col = ifelse(value[[1]] &gt; 0, &quot;#E41A1C&quot;, &quot;#377EB8&quot;), pch = 16, cex = 0.5) }, bg.col = chr_bg_color[tagments$chr], track.margin = c(0.02, 0)) circos.yaxis(side = &quot;left&quot;, at = seq(-0.6, 0.6, by = 0.3), sector.index = get.all.sector.index()[1], labels.cex = 0.4) circos.track(ylim = c(0, 1), track.height = mm_h(2), bg.col = add_transparency(chr_bg_color[tagments$chr], 0)) } circos.nested(f1, f2, correspondance, connection_col = chr_bg_color[correspondance[[1]]]) Figure 13.4: Visualization of DMRs. "],["the-chorddiagram-function.html", "Chapter 14 The chordDiagram() function 14.1 Basic usage of making Chord diagram 14.2 Adjust by circos.par() 14.3 Colors 14.4 Link border 14.5 Highlight links 14.6 Orders of links 14.7 z-index of adding links 14.8 Self-links 14.9 Symmetric matrix 14.10 Directional relations 14.11 Scaling 14.12 Reduce 14.13 Input as a data frame", " Chapter 14 The chordDiagram() function One unique feature of circular layout is the circular visualization of relations between objects by links. See examples in http://circos.ca/intro/tabular_visualization/. Such type of plot is called Chord diagram. In circlize, it is easy to plot Chord diagram in a straightforward or in a highly customized way. There are two data formats that represent relations, either adjacency matrix or adjacency list. In adjacency matrix, value in \\(i^{th}\\) row and \\(j^{th}\\) column represents the relation from object in the \\(i^{th}\\) row and the object in the \\(j^{th}\\) column where the absolute value measures the strength of the relation. In adjacency list, relations are represented as a three-column data frame in which relations come from the first column and to the second column, and the third column represents the strength of the relation. Following code shows an example of an adjacency matrix. mat = matrix(1:9, 3) rownames(mat) = letters[1:3] colnames(mat) = LETTERS[1:3] mat ## A B C ## a 1 4 7 ## b 2 5 8 ## c 3 6 9 And the code in below is an example of an adjacency list. df = data.frame(from = letters[1:3], to = LETTERS[1:3], value = 1:3) df ## from to value ## 1 a A 1 ## 2 b B 2 ## 3 c C 3 Actually, it is not difficult to convert between these two formats. There are also R packages and functions do the conversion such as in reshape2 package, melt() converts a matrix to a data frame and dcast() converts the data frame back to the matrix. Chord diagram shows the information of the relation from several levels. 1. the links are straightforward to show the relations between objects; 2. width of links are proportional to the strength of the relation which is more illustrative than other graphic mappings; 3. colors of links can be another graphic mapping for relations; 4. width of sectors represents total strength for an object which connects to other objects or is connected from other objects. You can find an interesting example of using Chord diagram to visualize leagues system of players clubs by their national team from https://gjabel.wordpress.com/2014/06/05/world-cup-players-representation-by-league-system/ and the adapted code is at https://jokergoo.github.io/circlize_examples/example/wc2014.html. In circlize package, there is a chordDiagram() function that supports both adjacency matrix and adjacency list. For different formats of input, the corresponding format of graphic parameters will be different either. E.g. when the input is a matrix, since information of the links in the Chord diagram is stored in the matrix, corresponding graphics for the links sometimes should also be specified as a matrix, while if the input is a data frame, the graphic parameters for links only need to be specified as an additional column to the data frame. Using the matrix is very straightforward and makes goodlooking plots, while using the data frame provides more flexibility for controlling the Chord diagram. Thus, in this chapter, we will show usage for both adjacency matrix and list. Since the usage for the two types of inputs are highly similar, in this chapter, we mainly show figures generated from the matrix, but still show the code which uses adjacency list. 14.1 Basic usage of making Chord diagram First let’s generate a random matrix and the corresponding adjacency list. set.seed(999) mat = matrix(sample(18, 18), 3, 6) rownames(mat) = paste0(&quot;S&quot;, 1:3) colnames(mat) = paste0(&quot;E&quot;, 1:6) mat ## E1 E2 E3 E4 E5 E6 ## S1 4 14 13 17 5 2 ## S2 7 1 6 8 12 15 ## S3 9 10 3 16 11 18 df = data.frame(from = rep(rownames(mat), times = ncol(mat)), to = rep(colnames(mat), each = nrow(mat)), value = as.vector(mat), stringsAsFactors = FALSE) df ## from to value ## 1 S1 E1 4 ## 2 S2 E1 7 ## 3 S3 E1 9 ## 4 S1 E2 14 ## 5 S2 E2 1 ## 6 S3 E2 10 ## 7 S1 E3 13 ## 8 S2 E3 6 ## 9 S3 E3 3 ## 10 S1 E4 17 ## 11 S2 E4 8 ## 12 S3 E4 16 ## 13 S1 E5 5 ## 14 S2 E5 12 ## 15 S3 E5 11 ## 16 S1 E6 2 ## 17 S2 E6 15 ## 18 S3 E6 18 The simplest usage is just calling chordDiagram() with mat (Figure 14.1). chordDiagram(mat) Figure 14.1: Basic usages of chordDiagram(). circos.clear() or call with df: chordDiagram(df) circos.clear() The default Chord Diagram consists of a track of labels, a track of grids (or you can call it lines, rectangles) with axes, and links. Sectors which correspond to rows in the matrix locate at the bottom half of the circle. The order of sectors is the order of union(rownames(mat), colnames(mat)) or union(df[[1]], df[[2]]) if input is a data frame. The order of sectors can be controlled by order argument (Figure 14.2, left). Of course, the length of order vector should be same as the number of sectors. In following code, S1, S2 and S3 should better be put together since they belong to a same group, which is same for E* sectors. Of course, you can give a order which mix S* and E* (Figure 14.2, right), but it is not recommended because it is bad for reading the plot. You can find more information of setting grouped Chord diagrams (two or more groups) in Section 15.6. par(mfrow = c(1, 2)) chordDiagram(mat, order = c(&quot;S2&quot;, &quot;S1&quot;, &quot;S3&quot;, &quot;E4&quot;, &quot;E1&quot;, &quot;E5&quot;, &quot;E2&quot;, &quot;E6&quot;, &quot;E3&quot;)) circos.clear() chordDiagram(mat, order = c(&quot;S2&quot;, &quot;S1&quot;, &quot;E4&quot;, &quot;E1&quot;, &quot;S3&quot;, &quot;E5&quot;, &quot;E2&quot;, &quot;E6&quot;, &quot;E3&quot;)) Figure 14.2: Adjust sector orders in Chord diagram. Left: sectors are still grouped after reordering; right: sectors are not grouped. circos.clear() Under default settings, the grid colors which represent sectors are randomly generated, and the link colors are same as grid colors which correspond to rows (or the first column if the input is an adjacency list) but with 50% transparency. 14.2 Adjust by circos.par() Since Chord Diagram is implemented by basic circlize functions, like normal circular plot, the layout can be customized by circos.par(). The gaps between sectors can be set by circos.par(gap.after = ...) (Figure 14.3). It is useful when you want to distinguish sectors between rows and columns. Please note since you change default graphical settings, you need to use circos.clear() in the end of the plot to reset it. circos.par(gap.after = c(rep(5, nrow(mat)-1), 15, rep(5, ncol(mat)-1), 15)) chordDiagram(mat) Figure 14.3: Set gaps in Chord diagram. circos.clear() If the input is a data frame: circos.par(gap.after = c(rep(5, length(unique(df[[1]]))-1), 15, rep(5, length(unique(df[[2]]))-1), 15)) chordDiagram(df) circos.clear() As explained in Section 2.4, gap.after can also specified as a named vector: circos.par(gap.after = c(&quot;S1&quot; = 5, &quot;S2&quot; = 5, &quot;S3&quot; = 15, &quot;E1&quot; = 5, &quot;E2&quot; = 5, &quot;E3&quot; = 5, &quot;E4&quot; = 5, &quot;E5&quot; = 5, &quot;E6&quot; = 15)) chordDiagram(mat) circos.clear() To make it simpler, users can directly set big.gap in chordDiagram() (Figure 14.4). The value of big.gap corresponds to the gap between row sectors and column sectors (or first-column sectors and second-column sectors in the input is a data frame). Internally a proper gap.after is assigned to circos.par(). Note it will only work when there is no overlap between row sectors and column sectors, or in other words, rows and columns in the matrix, or the first column and the second column in the data frame represent two different groups. chordDiagram(mat, big.gap = 30) Figure 14.4: Directly set big.gap in chordDiagram(). circos.clear() small.gap argument controls the gap between sectors corresponding to either matrix rows or columns. The default value is 1 degree and normally you don’t need to set it. big.gap and small.gap can also be set in the scenarios where number of groups is larger than two, see Section 15.6 for more details. Similar to a normal circular plot, the first sector (which is the first row in the adjacency matrix or the first row in the adjacency list) starts from right center of the circle and sectors are arranged clock-wisely. The start degree for the first sector can be set by circos.par(start.degree = ...) and the direction can be set by circos.par(clock.wise = ...) (Figure 14.5). In Figure 14.5 (left), setting circos.par(clock.wise = FALSE) makes the link so twisted. Actually making the direction reverse clock wise can also be done by setting a reversed order of all sectors (Figure 14.5, right). As we can see, the links in the left plot are very twisted, while it still looks fine in the right plot. The reason is chordDiagram() automatically optimizes the positions of links according to the arrangement of sectors. par(mfrow = c(1, 2)) circos.par(start.degree = 85, clock.wise = FALSE) chordDiagram(mat) circos.clear() circos.par(start.degree = 85) chordDiagram(mat, order = c(rev(colnames(mat)), rev(rownames(mat)))) Figure 14.5: Change position and orientation of Chord diagram. circos.clear() 14.3 Colors 14.3.1 Set grid colors Grids have different colors to represent different sectors. Generally, sectors are divided into two groups. One contains sectors defined in rows of the matrix or the first column in the data frame, and the other contains sectors defined in columns of the matrix or the second column in the data frame. Thus, links connect objects in the two groups. By default, link colors are same as the color for the corresponding sectors in the first group. Changing colors of grids may change the colors of links as well. Colors for grids can be set through grid.col argument. Values of grid.col better be a named vector of which names correspond to sector names. If it is has no name index, the order of grid.col is assumed to have the same order as sectors (Figure 14.6). If you want to colors to be the same as the sectors from the matrix columns or the second column in the data frame, simply transpose the matrix (Figure 14.6 right). grid.col = c(S1 = &quot;red&quot;, S2 = &quot;green&quot;, S3 = &quot;blue&quot;, E1 = &quot;grey&quot;, E2 = &quot;grey&quot;, E3 = &quot;grey&quot;, E4 = &quot;grey&quot;, E5 = &quot;grey&quot;, E6 = &quot;grey&quot;) chordDiagram(mat, grid.col = grid.col) chordDiagram(t(mat), grid.col = grid.col) Figure 14.6: Set grid colors in Chord diagram. 14.3.2 Set link colors Transparency of link colors can be set by transparency argument (Figure 14.7). The value should between 0 to 1 in which 0 means no transparency and 1 means full transparency. Default transparency is 0.5. chordDiagram(mat, grid.col = grid.col, transparency = 0) Figure 14.7: Transparency for links in Chord diagram. For adjacecy matrix, colors for links can be customized by providing a matrix of colors. In the following example, we use rand_color() to generate a random color matrix. Note since col_mat already contains transparency, transparency will be ignored if it is set (Figure 14.8). col_mat = rand_color(length(mat), transparency = 0.5) dim(col_mat) = dim(mat) # to make sure it is a matrix chordDiagram(mat, grid.col = grid.col, col = col_mat) Figure 14.8: Set a color matrix for links in Chord diagram. While for ajacency list, colors for links can be customized as a vector. col = rand_color(nrow(df)) chordDiagram(df, grid.col = grid.col, col = col) When the strength of the relation (e.g. correlations) represents as continuous values, col can also be specified as a self-defined color mapping function. chordDiagram() accepts a color mapping generated by colorRamp2() (Figure 14.9). col_fun = colorRamp2(range(mat), c(&quot;#FFEEEE&quot;, &quot;#FF0000&quot;), transparency = 0.5) chordDiagram(mat, grid.col = grid.col, col = col_fun) Figure 14.9: Set a color mapping function for links in Chord diagram. The color mapping function also works for adjacency list, but it will be applied to the third column in the data frame, so you need to make sure the third column has the proper values. chordDiagram(df, grid.col = grid.col, col = col_fun) # or chordDiagram(df, grid.col = grid.col, col = col_fun(df[, 3])) When the input is a matrix, sometimes you don’t need to generate the whole color matrix. You can just provide colors which correspond to rows or columns so that links from a same row/column will have the same color (Figure 14.10). Here note values of colors can be set as numbers, color names or hex code, same as in the base R graphics. chordDiagram(mat, grid.col = grid.col, row.col = 1:3) chordDiagram(mat, grid.col = grid.col, column.col = 1:6) Figure 14.10: Set link colors same as row sectors or column sectors in Chord diagram. row.col and column.col is specifically designed for matrix. There is no similar settings for ajacency list. To emphasize again, transparency of links can be included in col, row.col or column.col, if transparency is already set there, transparency argument will be ignored. In Section 14.5, we will introduce how to highlight subset of links by only assigning colors to them. 14.4 Link border link.lwd, link.lty and link.border control the line width, the line style and the color of the link border. All these three parameters can be set either a single scalar or a matrix if the input is adjacency matrix. If it is set as a single scalar, it means all links share the same style (Figure 14.11). chordDiagram(mat, grid.col = grid.col, link.lwd = 2, link.lty = 2, link.border = &quot;red&quot;) Figure 14.11: Line style for Chord diagram. If it is set as a matrix, it should have same dimension as mat (Figure 14.12). lwd_mat = matrix(1, nrow = nrow(mat), ncol = ncol(mat)) lwd_mat[mat &gt; 12] = 2 border_mat = matrix(NA, nrow = nrow(mat), ncol = ncol(mat)) border_mat[mat &gt; 12] = &quot;red&quot; chordDiagram(mat, grid.col = grid.col, link.lwd = lwd_mat, link.border = border_mat) Figure 14.12: Set line style as a matrix. The matrix is not necessary to have same dimensions as in mat. It can also be a sub matrix (Figure 14.13). For rows or columns of which the corresponding values are not specified in the matrix, default values are filled in. It must have row names and column names so that the settings can be mapped to the correct links. border_mat2 = matrix(&quot;black&quot;, nrow = 1, ncol = ncol(mat)) rownames(border_mat2) = rownames(mat)[2] colnames(border_mat2) = colnames(mat) chordDiagram(mat, grid.col = grid.col, link.lwd = 2, link.border = border_mat2) Figure 14.13: Set line style as a sub matrix. To be more convenient, graphic parameters can be set as a three-column data frame in which the first two columns correspond to row names and column names in the matrix, and the third column corresponds to the graphic parameters (Figure 14.14). lty_df = data.frame(c(&quot;S1&quot;, &quot;S2&quot;, &quot;S3&quot;), c(&quot;E5&quot;, &quot;E6&quot;, &quot;E4&quot;), c(1, 2, 3)) lwd_df = data.frame(c(&quot;S1&quot;, &quot;S2&quot;, &quot;S3&quot;), c(&quot;E5&quot;, &quot;E6&quot;, &quot;E4&quot;), c(2, 2, 2)) border_df = data.frame(c(&quot;S1&quot;, &quot;S2&quot;, &quot;S3&quot;), c(&quot;E5&quot;, &quot;E6&quot;, &quot;E4&quot;), c(1, 1, 1)) chordDiagram(mat, grid.col = grid.col, link.lty = lty_df, link.lwd = lwd_df, link.border = border_df) Figure 14.14: Set line style as a data frame. It is much easier if the input is a data frame, you only need to set graphic settings as a vecotr. chordDiagram(df, grid.col = grid.col, link.lty = sample(1:3, nrow(df), replace = TRUE), link.lwd = runif(nrow(df))*2, link.border = sample(0:1, nrow(df), replace = TRUE)) 14.5 Highlight links Sometimes we want to highlight some links to emphasize the importance of such relations. Highlighting by different border styles are introduced in Section 14.4 and here we focus on highlighting by colors. There are two ways to highlight links, one is to set different transparency to different links and the other is to only draw links that needs to be highlighted. Based on this rule and ways to assign colors to links (introduced in Section 14.3.2), we can highlight links which come from a same sector by assigning colors with different transparency by row.col argument (Figure 14.15). chordDiagram(mat, grid.col = grid.col, row.col = c(&quot;#FF000080&quot;, &quot;#00FF0010&quot;, &quot;#0000FF10&quot;)) Figure 14.15: Highlight links by transparency. We can also highlight links with values larger than a cutoff. There are at least three ways to do it. First, construct a color matrix and set links with small values to full transparency. Since link colors can be specified as a matrix, we can set the transparency of those links to a high value or even set to full transparency (Figure 14.16). In following example, links with value less than 12 is set to #00000000. col_mat[mat &lt; 12] = &quot;#00000000&quot; chordDiagram(mat, grid.col = grid.col, col = col_mat) Figure 14.16: Highlight links by color matrix. Following code demonstrates using a color mapping function to map values to different transparency. Note this is also workable for adjacency list. col_fun = function(x) ifelse(x &lt; 12, &quot;#00000000&quot;, &quot;#FF000080&quot;) chordDiagram(mat, grid.col = grid.col, col = col_fun) For both color matrix and color mapping function, actually all links are all drawn and the reason why you cannot see some of them is they are assigned with full transparency. If a three-column data frame is used to assign colors to links of interest, links which are not defined in col_df are not drawn (Figure 14.17). col_df = data.frame(c(&quot;S1&quot;, &quot;S2&quot;, &quot;S3&quot;), c(&quot;E5&quot;, &quot;E6&quot;, &quot;E4&quot;), c(&quot;#FF000080&quot;, &quot;#00FF0080&quot;, &quot;#0000FF80&quot;)) chordDiagram(mat, grid.col = grid.col, col = col_df) Figure 14.17: Highlight links by data frame. Highlighting links is relatively simple for adjacency list that you only need to construct a vector of colors according to what links you want to highlight. col = rand_color(nrow(df)) col[df[[3]] &lt; 10] = &quot;#00000000&quot; chordDiagram(df, grid.col = grid.col, col = col) Some figure formats do not support transparency such as GIF format. Here the other argument link.visible is recently introduced to circlize package which may provide a simple way to control the visibility of links. The value can be set as an logical matrix for adjacency matrix or a logical vector for adjacency list (Figure 14.18). col = rand_color(nrow(df)) chordDiagram(df, grid.col = grid.col, link.visible = df[[3]] &gt;= 10) Figure 14.18: Highlight links by setting link.visible. 14.6 Orders of links Orders of links on every sector are adjusted automatically to make them look nice. But sometimes sorting links according to the width on the sector is useful for detecting potential features. link.sort and link.decreasing can be set to control the order of positioning links on sectors (Figure 14.19). chordDiagram(mat, grid.col = grid.col, link.sort = TRUE, link.decreasing = TRUE) title(&quot;link.sort = TRUE, link.decreasing = TRUE&quot;, cex = 0.6) chordDiagram(mat, grid.col = grid.col, link.sort = TRUE, link.decreasing = FALSE) title(&quot;link.sort = TRUE, link.decreasing = FALSE&quot;, cex = 0.6) Figure 14.19: Order of positioning links on sectors. 14.7 z-index of adding links The default order of adding links to the plot is based on their order in the matrix or in the data frame. Normally, transparency should be set to the link colors so that they will not overlap to each other. In most cases, this looks fine, but sometimes, it improves the visualization to put wide links more forward and to put small links more backward in the plot. This can be set by link.zindex argument which defines the order of adding links one above the other. Larger value means the corresponding link is added later (Figure 14.20). chordDiagram(mat, grid.col = grid.col, transparency = 0) chordDiagram(mat, grid.col = grid.col, transparency = 0, link.zindex = rank(mat)) Figure 14.20: z-index of adding links. Similar code if the input is a data frame. chordDiagram(df, grid.col = grid.col, transparency = 0, link.zindex = rank(df[[3]])) 14.8 Self-links How to set self links dependends on whether the information needs to be duplicated. The self.link argument can be set to 1 or 2 for the two different scenarios. Check the difference in Figure 14.21 (the black link on sector a). df2 = data.frame(start = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;), end = c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) chordDiagram(df2, grid.col = 1:3, self.link = 1) title(&quot;self.link = 1&quot;) chordDiagram(df2, grid.col = 1:3, self.link = 2) title(&quot;self.link = 2&quot;) Figure 14.21: Self-links in Chord diagram. 14.9 Symmetric matrix When the matrix is symmetric, by setting symmetric = TRUE, only lower triangular matrix without the diagonal will be used (Figure 14.22). mat3 = matrix(rnorm(25), 5) colnames(mat3) = letters[1:5] cor_mat = cor(mat3) col_fun = colorRamp2(c(-1, 0, 1), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)) chordDiagram(cor_mat, grid.col = 1:5, symmetric = TRUE, col = col_fun) title(&quot;symmetric = TRUE&quot;) chordDiagram(cor_mat, grid.col = 1:5, col = col_fun) title(&quot;symmetric = FALSE&quot;) Figure 14.22: Symmetric matrix for Chord diagram. 14.10 Directional relations In some cases, when the input is a matrix, rows and columns represent directions, or when the input is a data frame, the first column and second column represent directions. Argument directional is used to illustrate such direction on the plot. directional with value 1 means the direction is from rows to columns (or from the first column to the second column for the adjacency list) while -1 means the direction is from columns to rows (or from the second column to the first column for the adjacency list). A value of 2 means bi-directional. By default, the two ends of links have unequal height (Figure 14.23) to represent the directions. The position of starting end of the link is shorter than the other end to give users the feeling that the link is moving out. If this is not what your correct feeling, you can set diffHeight to a negative value. par(mfrow = c(1, 3)) chordDiagram(mat, grid.col = grid.col, directional = 1) chordDiagram(mat, grid.col = grid.col, directional = 1, diffHeight = mm_h(5)) chordDiagram(mat, grid.col = grid.col, directional = -1) Figure 14.23: Represent directions by different height of link ends. Row names and column names in mat can also overlap. In this case, showing direction of the link is important to distinguish them (Figure 14.24). mat2 = matrix(sample(100, 35), nrow = 5) rownames(mat2) = letters[1:5] colnames(mat2) = letters[1:7] mat2 ## a b c d e f g ## a 42 44 90 35 58 66 36 ## b 8 98 57 9 86 55 93 ## c 24 38 23 60 67 50 96 ## d 19 17 95 7 51 18 82 ## e 52 49 47 88 74 92 31 chordDiagram(mat2, grid.col = 1:7, directional = 1, row.col = 1:5) Figure 14.24: Chord diagram where row names and column names overlap. If you do not need self-link for which two ends of a link are in a same sector, just set corresponding values to 0 in the matrix (Figure 14.25). mat3 = mat2 for(cn in intersect(rownames(mat3), colnames(mat3))) { mat3[cn, cn] = 0 } mat3 ## a b c d e f g ## a 0 44 90 35 58 66 36 ## b 8 0 57 9 86 55 93 ## c 24 38 0 60 67 50 96 ## d 19 17 95 0 51 18 82 ## e 52 49 47 88 0 92 31 chordDiagram(mat3, grid.col = 1:7, directional = 1, row.col = 1:5) Figure 14.25: Directional Chord diagram without self links. Links can have arrows to represent directions (Figure 14.26). When direction.type is set to arrows, Arrows are added at the center of links. Similar as other graphics parameters for links, the parameters for drawing arrows such as arrow color and line type can either be a scalar, a matrix, or a three-column data frame. If link.arr.col is set as a data frame, only links specified in the data frame will have arrows. Pleast note this is the only way to draw arrows to subset of links. arr.col = data.frame(c(&quot;S1&quot;, &quot;S2&quot;, &quot;S3&quot;), c(&quot;E5&quot;, &quot;E6&quot;, &quot;E4&quot;), c(&quot;black&quot;, &quot;black&quot;, &quot;black&quot;)) chordDiagram(mat, grid.col = grid.col, directional = 1, direction.type = &quot;arrows&quot;, link.arr.col = arr.col, link.arr.length = 0.2) Figure 14.26: Use arrows to represent directions in Chord diagram. If combining both arrows and diffHeight, it will give you better visualization (Figure 14.27). arr.col = data.frame(c(&quot;S1&quot;, &quot;S2&quot;, &quot;S3&quot;), c(&quot;E5&quot;, &quot;E6&quot;, &quot;E4&quot;), c(&quot;black&quot;, &quot;black&quot;, &quot;black&quot;)) chordDiagram(mat, grid.col = grid.col, directional = 1, direction.type = c(&quot;diffHeight&quot;, &quot;arrows&quot;), link.arr.col = arr.col, link.arr.length = 0.2) Figure 14.27: Use both arrows and link height to represent directions in Chord diagram. There is another arrow type: big.arrow which is efficient to visualize arrows when there are too many links (Figure 14.28). matx = matrix(rnorm(64), 8) chordDiagram(matx, directional = 1, direction.type = c(&quot;diffHeight&quot;, &quot;arrows&quot;), link.arr.type = &quot;big.arrow&quot;) Figure 14.28: Use big arrows to represent directions in Chord diagram. If diffHeight is set to a negative value, the start ends are longer than the other ends (Figure 14.29). chordDiagram(matx, directional = 1, direction.type = c(&quot;diffHeight&quot;, &quot;arrows&quot;), link.arr.type = &quot;big.arrow&quot;, diffHeight = -mm_h(2)) Figure 14.29: Use big arrows to represent directions in Chord diagram. It is almost the same to visualize directional Chord diagram form a adjacency list. chordDiagram(df, directional = 1) As shown in the previous Figures, there are bars on the source sector side that show the proportion of target sectors (actually it is not necessarily to be that, the bars are put on the side where the links are shorter and diffHeight with a positive value). The bars can be removed by setting link.target.prop = FALSE. The height of the bars is controlled by target.prop.height argument. par(mfrow = c(1, 2)) chordDiagram(mat, grid.col = grid.col, directional = 1, link.target.prop = FALSE) chordDiagram(mat, grid.col = grid.col, directional = 1, diffHeight = mm_h(10), target.prop.height = mm_h(8)) Figure 14.30: Control argument link.target.prop and target.prop.height. 14.11 Scaling The link on Chord diagram represents the “absolute value” of the relations. Sometimes for a certain sector, we might want to see relatively, how much of it goes to other sectors. In this case, scale argument can be set to TRUE so that on each sector, the value represents the fraction of the interaction going to one other sector (Figure 14.31). set.seed(999) mat = matrix(sample(18, 18), 3, 6) rownames(mat) = paste0(&quot;S&quot;, 1:3) colnames(mat) = paste0(&quot;E&quot;, 1:6) grid.col = c(S1 = &quot;red&quot;, S2 = &quot;green&quot;, S3 = &quot;blue&quot;, E1 = &quot;grey&quot;, E2 = &quot;grey&quot;, E3 = &quot;grey&quot;, E4 = &quot;grey&quot;, E5 = &quot;grey&quot;, E6 = &quot;grey&quot;) par(mfrow = c(1, 2)) chordDiagram(mat, grid.col = grid.col) title(&quot;Default&quot;) chordDiagram(mat, grid.col = grid.col, scale = TRUE) title(&quot;scale = TRUE&quot;) Figure 14.31: Scaling on sectors. After scaling, all sectors have the same size and the data range of each sector are all c(0, 1). 14.12 Reduce If a sector in Chord Diagram is too small, it will be removed from the original matrix, since basically it can be ignored visually from the plot. In the following matrix, the second row and third column contain tiny values. mat = matrix(rnorm(36), 6, 6) rownames(mat) = paste0(&quot;R&quot;, 1:6) colnames(mat) = paste0(&quot;C&quot;, 1:6) mat[2, ] = 1e-10 mat[, 3] = 1e-10 In the Chord Diagram, categories corresponding to the second row and the third column will be removed (R2 and C3 are removed). chordDiagram(mat) circos.info() ## All your sectors: ## [1] &quot;R1&quot; &quot;R3&quot; &quot;R4&quot; &quot;R5&quot; &quot;R6&quot; &quot;C1&quot; &quot;C2&quot; &quot;C4&quot; &quot;C5&quot; &quot;C6&quot; ## ## All your tracks: ## [1] 1 2 ## ## Your current sector.index is C6 ## Your current track.index is 2 The reduce argument controls the size of sectors to be removed. The value is a percent of the size of a sector to the total size of all sectors. You can also explictly remove sectors by assigning corresponding values to 0. mat[2, ] = 0 mat[, 3] = 0 All parameters for sectors such as colors or gaps between sectors are also automatically reduced accordingly by the function. 14.13 Input as a data frame As mentioned before, both matrix and data frame can be used to represent relations between two sets of features. In previous examples, we mainly demonstrate the use of chordDiagram() with matrix as input. Also we show the code with data frame as input for each functionality. Here we will go through these functionality again with data frames and we also show some unique features which is only usable for data frames. When the input is a data frame, number of rows in the data frame corresponds to the number of links on the Chord diagram. Many arguments can be set as a vector which have the same length as the number of rows of the input data frame. They are: transparency col. Note, col can also be a color mapping function generated from colorRamp2(). link.border link.lwd link.lty link.arr.length link.arr.width link.arr.type link.arr.lwd link.arr.lty link.arr.col link.visible link.zindex Since all of them are already demonstrated in previous sections, we won’t show them again here. The following two sections list unique features only from data frames. 14.13.1 Multiple links between two sectors If the input is a matrix, there can only be one link from sector A to B, but for the data frame, there can be mulitple links for a same pair of sectors. In following example, each pair of sectors have two links, one for positive value and the other for negative value. df = expand.grid(letters[1:3], LETTERS[1:4]) df1 = df df1$value = sample(10, nrow(df), replace = TRUE) df2 = df df2$value = -sample(10, nrow(df), replace = TRUE) df = rbind(df1, df2) grid.col = structure(1:7, names = c(letters[1:3], LETTERS[1:4])) chordDiagram(df, col = ifelse(df$value &gt; 0, &quot;red&quot;, &quot;green&quot;), grid.col = grid.col) Figure 14.32: Multiple links for a same pair of sectors. This functionality is useful when you want to visualize Figure 14.32 as two Chord diagrams, one for positive values and one for negative values, but still correspond the size of sector to the sum of both positive and negative values. par(mfrow = c(1, 2)) chordDiagram(df, col = &quot;red&quot;, link.visible = df$value &gt; 0, grid.col = grid.col) title(&quot;Positive links&quot;) chordDiagram(df, col = &quot;green&quot;, link.visible = df$value &lt; 0, grid.col = grid.col) title(&quot;Negative links&quot;) Figure 14.33: Split positive links and negative links. 14.13.2 Unequal width of the link ends Almost all of the Chord diagrams shown in this chapter (except Figure 14.31), the width of the two ends of a link is always the same. This means same amount of information comes from one sector and goes to the other sector. However, for some cases, this is not always true. For example, when do scaling on sectors, the link actually has unequal width of the two ends (Figure 14.31 right). Since the two ends have different width, now the data frame needs two numeric columns which correspond to the two ends of the links. Check following example: df = expand.grid(letters[1:3], LETTERS[1:4]) df$value = 1 df$value2 = 3 # the names of the two columns do not matter par(mfrow = c(1, 2)) chordDiagram(df[, 1:3], grid.col = grid.col) title(&quot;one column of values&quot;) chordDiagram(df[, 1:4], grid.col = grid.col) # note we use two value-columns here title(&quot;two columns of values&quot;) Figure 14.34: Unequal width of the link ends. "],["advanced-usage-of-chorddiagram.html", "Chapter 15 Advanced usage of chordDiagram() 15.1 Organization of tracks 15.2 Customize sector labels 15.3 Customize sector axes 15.4 Put horizontally or vertically symmetric 15.5 Compare two Chord diagrams 15.6 Multiple-group Chord diagram", " Chapter 15 Advanced usage of chordDiagram() The default style of chordDiagram() is somehow enough for most visualization tasks, still you can have more configurations on the plot. The usage is same for both ajacency matrix and ajacency list, so we only demonstrate with the matrix. 15.1 Organization of tracks By default, chordDiagram() creates two tracks, one track for labels and one track for grids with axes. chordDiagram(mat) circos.info() ## All your sectors: ## [1] &quot;S1&quot; &quot;S2&quot; &quot;S3&quot; &quot;E1&quot; &quot;E2&quot; &quot;E3&quot; &quot;E4&quot; &quot;E5&quot; &quot;E6&quot; ## ## All your tracks: ## [1] 1 2 ## ## Your current sector.index is E6 ## Your current track.index is 2 These two tracks can be controlled by annotationTrack argument. Available values for this argument are grid, name and axis. The height of annotation tracks can be set by annotationTrackHeight which is the percentage to the radius of unit circle and can be set by mm_h() function with an absolute unit. Axes are only added if grid is set in annotationTrack (Figure 15.1). chordDiagram(mat, grid.col = grid.col, annotationTrack = &quot;grid&quot;) chordDiagram(mat, grid.col = grid.col, annotationTrack = c(&quot;name&quot;, &quot;grid&quot;), annotationTrackHeight = c(0.03, 0.01)) chordDiagram(mat, grid.col = grid.col, annotationTrack = NULL) Figure 15.1: Track organization in chordDiagram(). Several empty tracks can be allocated before Chord diagram is drawn. Then self-defined graphics can be added to these empty tracks afterwards. The number of pre-allocated tracks can be set through preAllocateTracks. chordDiagram(mat, preAllocateTracks = 2) circos.info() ## All your sectors: ## [1] &quot;S1&quot; &quot;S2&quot; &quot;S3&quot; &quot;E1&quot; &quot;E2&quot; &quot;E3&quot; &quot;E4&quot; &quot;E5&quot; &quot;E6&quot; ## ## All your tracks: ## [1] 1 2 3 4 ## ## Your current sector.index is E6 ## Your current track.index is 4 The default settings for pre-allocated tracks are: list(ylim = c(0, 1), track.height = circos.par(&quot;track.height&quot;), bg.col = NA, bg.border = NA, bg.lty = par(&quot;lty&quot;), bg.lwd = par(&quot;lwd&quot;)) The default settings for pre-allocated tracks can be overwritten by specifying preAllocateTracks as a list. chordDiagram(mat, annotationTrack = NULL, preAllocateTracks = list(track.height = 0.3)) If more than one tracks need to be pre-allocated, just specify preAllocateTracks as a list which contains settings for each track: chordDiagram(mat, annotationTrack = NULL, preAllocateTracks = list(list(track.height = 0.1), list(bg.border = &quot;black&quot;))) By default chordDiagram() provides poor supports for customization of sector labels and axes, but with preAllocateTracks it is rather easy to customize them. Such customization will be introduced in next section. 15.2 Customize sector labels In chordDiagram(), there is no argument to control the style of sector labels, but this can be done by first pre-allocating an empty track and customizing the labels in it later. In the following example, one track is firstly allocated and a Chord diagram is added without label track and axes. Later, the first track is updated with adding labels with clockwise facings (Figure 15.2). chordDiagram(mat, grid.col = grid.col, annotationTrack = &quot;grid&quot;, preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(mat)))))) # we go back to the first track and customize sector labels circos.track(track.index = 1, panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, facing = &quot;clockwise&quot;, niceFacing = TRUE, adj = c(0, 0.5)) }, bg.border = NA) # here set bg.border to NA is important Figure 15.2: Change label directions. In the following example, the labels are put on the grids (Figure 15.3). Please note circos.text() and get.cell.meta.data() can be used outside panel.fun if the sector index and track index are specified explicitly. chordDiagram(mat, grid.col = grid.col, annotationTrack = c(&quot;grid&quot;, &quot;axis&quot;), annotationTrackHeight = mm_h(5)) for(si in get.all.sector.index()) { xlim = get.cell.meta.data(&quot;xlim&quot;, sector.index = si, track.index = 1) ylim = get.cell.meta.data(&quot;ylim&quot;, sector.index = si, track.index = 1) circos.text(mean(xlim), mean(ylim), si, sector.index = si, track.index = 1, facing = &quot;bending.inside&quot;, niceFacing = TRUE, col = &quot;white&quot;) } Figure 15.3: Put sector labels to the grid. For the last example in this section, if the width of the sector is less than 10 degree, the labels are added in the radical direction (Figure 15.4). set.seed(123) mat2 = matrix(rnorm(100), 10) chordDiagram(mat2, annotationTrack = &quot;grid&quot;, preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(mat)))))) circos.track(track.index = 1, panel.fun = function(x, y) { xlim = get.cell.meta.data(&quot;xlim&quot;) xplot = get.cell.meta.data(&quot;xplot&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) sector.name = get.cell.meta.data(&quot;sector.index&quot;) if(abs(xplot[2] - xplot[1]) &lt; 10) { circos.text(mean(xlim), ylim[1], sector.name, facing = &quot;clockwise&quot;, niceFacing = TRUE, adj = c(0, 0.5), col = &quot;red&quot;) } else { circos.text(mean(xlim), ylim[1], sector.name, facing = &quot;inside&quot;, niceFacing = TRUE, adj = c(0.5, 0), col= &quot;blue&quot;) } }, bg.border = NA) Figure 15.4: Adjust label direction according to the width of sectors. When you set direction of sector labels as radical (clockwise or reverse.clockwise), if the labels are too long and exceed your figure region, you can either decrease the size of the font or set canvas.xlim and canvas.ylim parameters in circos.par() to wider intervals. 15.3 Customize sector axes Axes are helpful to correspond to the absolute values of links. By default chordDiagram() adds axes on the grid track. But it is easy to customize one with self-defined code. In following example code, we draw another type of axes which show relative percent on sectors. We first pre-allocate an empty track by preAllocateTracks and come back to this track to add axes later. You may see we add the first axes to the top of second track. You can also put them to the bottom of the first track. # similar as the previous example, but we only plot the grid track chordDiagram(mat, grid.col = grid.col, annotationTrack = &quot;grid&quot;, preAllocateTracks = list(track.height = mm_h(5))) for(si in get.all.sector.index()) { circos.axis(h = &quot;top&quot;, labels.cex = 0.3, sector.index = si, track.index = 2) } Now we go back to the first track to add the second type of axes and sector names. In panel.fun, if the sector is less than 30 degree, the break for the axis is set to 0.5 (Figure 15.5). # the second axis as well as the sector labels are added in this track circos.track(track.index = 1, panel.fun = function(x, y) { xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) sector.name = get.cell.meta.data(&quot;sector.index&quot;) xplot = get.cell.meta.data(&quot;xplot&quot;) circos.lines(xlim, c(mean(ylim), mean(ylim)), lty = 3) # dotted line by = ifelse(abs(xplot[2] - xplot[1]) &gt; 30, 0.2, 0.5) for(p in seq(by, 1, by = by)) { circos.text(p*(xlim[2] - xlim[1]) + xlim[1], mean(ylim) + 0.1, paste0(p*100, &quot;%&quot;), cex = 0.3, adj = c(0.5, 0), niceFacing = TRUE) } circos.text(mean(xlim), 1, sector.name, niceFacing = TRUE, adj = c(0.5, 0)) }, bg.border = NA) circos.clear() Figure 15.5: Customize sector axes for Chord diagram. 15.4 Put horizontally or vertically symmetric In Chord diagram, when there are two groups (which correspond to rows and columns if the input is an adjacency matrix), it is always visually beautiful to rotate the diagram to be symmetric on horizontal direction or vertical direction. See following example: par(mfrow = c(1, 2)) circos.par(start.degree = 0) chordDiagram(mat, grid.col = grid.col, big.gap = 20) abline(h = 0, lty = 2, col = &quot;#00000080&quot;) circos.clear() circos.par(start.degree = 90) chordDiagram(mat, grid.col = grid.col, big.gap = 20) abline(v = 0, lty = 2, col = &quot;#00000080&quot;) Figure 15.6: Rotate Chord diagram. circos.clear() 15.5 Compare two Chord diagrams Normally, in Chord diagram, values in mat are normalized to the summation of the absolute values in the matrix, which means the width for links only represents relative values. Then, when comparing two Chord diagrams, it is necessary that unit width of links in the two plots should be represented in a same scale. This problem can be solved by adding larger gaps to the Chord diagram which has smaller matrix. First we make the “big” Chord diagram. mat1 = matrix(sample(20, 25, replace = TRUE), 5) chordDiagram(mat1, directional = 1, grid.col = rep(1:5, 2), transparency = 0.5, big.gap = 10, small.gap = 1) # 10 and 1 are default values for the two arguments The second matrix only has half the values in mat1. mat2 = mat1 / 2 calc_gap() can be used to calculate the gap for the second Chord diagram to make the scale of the two Chord diagram the same. gap = calc_gap(mat1, mat2, big.gap = 10, small.gap = 1) chordDiagram(mat2, directional = 1, grid.col = rep(1:5, 2), transparency = 0.5, big.gap = gap, small.gap = 1) Now the scale of the two Chord diagrams (Figure 15.7) are the same if you compare the scale of axes in the two diagrams. Figure 15.7: Compare two Chord Diagrams in a same scale. To correctly use the functionality of calc_gap(), the two Chord diagram should have same value for small.gap and there should be no overlap between the two sets of the sectors. 15.6 Multiple-group Chord diagram From verion 0.4.10 of the circlize package, there is a new group argument in chordDiagram() function which is very convenient for making multiple-group Chord diagrams. I first generate a random matrix where there are three groups (A, B, and C). Note this new functionality works the same for the input as a data frame. mat1 = matrix(rnorm(25), nrow = 5) rownames(mat1) = paste0(&quot;A&quot;, 1:5) colnames(mat1) = paste0(&quot;B&quot;, 1:5) mat2 = matrix(rnorm(25), nrow = 5) rownames(mat2) = paste0(&quot;A&quot;, 1:5) colnames(mat2) = paste0(&quot;C&quot;, 1:5) mat3 = matrix(rnorm(25), nrow = 5) rownames(mat3) = paste0(&quot;B&quot;, 1:5) colnames(mat3) = paste0(&quot;C&quot;, 1:5) mat = matrix(0, nrow = 10, ncol = 10) rownames(mat) = c(rownames(mat2), rownames(mat3)) colnames(mat) = c(colnames(mat1), colnames(mat2)) mat[rownames(mat1), colnames(mat1)] = mat1 mat[rownames(mat2), colnames(mat2)] = mat2 mat[rownames(mat3), colnames(mat3)] = mat3 mat ## B1 B2 B3 B4 B5 C1 ## A1 0.9769734 3.2410399 0.51686204 2.1284519 0.4365235 -0.86551286 ## A2 -0.3745809 -0.4168576 0.36896453 -0.7413361 -0.4583653 -0.23627957 ## A3 1.0527115 0.2982276 -0.21538051 -1.0959963 -1.0633261 -0.19717589 ## A4 -1.0491770 0.6365697 0.06529303 0.0377884 1.2631852 1.10992029 ## A5 -1.2601552 -0.4837806 -0.03406725 0.3104807 -0.3496504 0.08473729 ## B1 0.0000000 0.0000000 0.00000000 0.0000000 0.0000000 1.65090747 ## B2 0.0000000 0.0000000 0.00000000 0.0000000 0.0000000 -0.05402813 ## B3 0.0000000 0.0000000 0.00000000 0.0000000 0.0000000 0.11924524 ## B4 0.0000000 0.0000000 0.00000000 0.0000000 0.0000000 0.24368743 ## B5 0.0000000 0.0000000 0.00000000 0.0000000 0.0000000 1.23247588 ## C2 C3 C4 C5 ## A1 0.75405379 -0.8953634 -0.61116592 0.54319406 ## A2 -0.49929202 -1.3108015 -1.18548008 -0.41433995 ## A3 0.21444531 1.9972134 2.19881035 -0.47624689 ## A4 -0.32468591 0.6007088 1.31241298 -0.78860284 ## A5 0.09458353 -1.2512714 -0.26514506 -0.59461727 ## B1 -0.51606383 -1.2362731 0.70758835 0.88465050 ## B2 -0.99250715 -1.2847157 -0.36365730 -1.01559258 ## B3 1.67569693 -0.5739735 0.05974994 1.95529397 ## B4 -0.44116322 0.6179858 -0.70459646 -0.09031959 ## B5 -0.72306597 1.1098481 -0.71721816 0.21453883 The main thing is to create “a grouping variable”. The variable contains the group labels and the sector names are used as the names in the vector. nm = unique(unlist(dimnames(mat))) group = structure(gsub(&quot;\\\\d&quot;, &quot;&quot;, nm), names = nm) group ## A1 A2 A3 A4 A5 B1 B2 B3 B4 B5 C1 C2 C3 C4 C5 ## &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; Assign group variable to the group argument: grid.col = structure(c(rep(2, 5), rep(3, 5), rep(4, 5)), names = c(paste0(&quot;A&quot;, 1:5), paste0(&quot;B&quot;, 1:5), paste0(&quot;C&quot;, 1:5))) chordDiagram(mat, group = group, grid.col = grid.col) Figure 15.8: Grouped Chord diagram. circos.clear() We can try another grouping: group = structure(gsub(&quot;^\\\\w&quot;, &quot;&quot;, nm), names = nm) group ## A1 A2 A3 A4 A5 B1 B2 B3 B4 B5 C1 C2 C3 C4 C5 ## &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; chordDiagram(mat, group = group, grid.col = grid.col) Figure 15.9: Grouped Chord diagram. A different grouping. circos.clear() The order of group controls the sector orders and if group is set as a factor, the order of levels controls the order of groups. group = structure(gsub(&quot;\\\\d&quot;, &quot;&quot;, nm), names = nm) group = factor(group[sample(length(group), length(group))], levels = c(&quot;C&quot;, &quot;A&quot;, &quot;B&quot;)) group ## B3 A3 B5 B2 C1 A1 A2 C4 A5 C2 C5 B4 A4 B1 C3 ## B A B B C A A C A C C B A B C ## Levels: C A B chordDiagram(mat, group = group, grid.col = grid.col) Figure 15.10: Grouped Chord diagram. Control the orders of groups. circos.clear() The gap between groups is controlled by big.gap argument and the gap between sectors is controlled by small.gap argument. group = structure(gsub(&quot;\\\\d&quot;, &quot;&quot;, nm), names = nm) chordDiagram(mat, group = group, grid.col = grid.col, big.gap = 20, small.gap = 5) Figure 15.11: Grouped Chord diagram. Control the gaps between groups. circos.clear() As a normal Chord diagram, the labels and other tracks can be manually adjusted: group = structure(gsub(&quot;\\\\d&quot;, &quot;&quot;, nm), names = nm) chordDiagram(mat, group = group, grid.col = grid.col, annotationTrack = c(&quot;grid&quot;, &quot;axis&quot;), preAllocateTracks = list( track.height = mm_h(4), track.margin = c(mm_h(4), 0) )) circos.track(track.index = 2, panel.fun = function(x, y) { sector.index = get.cell.meta.data(&quot;sector.index&quot;) xlim = get.cell.meta.data(&quot;xlim&quot;) ylim = get.cell.meta.data(&quot;ylim&quot;) circos.text(mean(xlim), mean(ylim), sector.index, cex = 0.6, niceFacing = TRUE) }, bg.border = NA) highlight.sector(rownames(mat1), track.index = 1, col = &quot;red&quot;, text = &quot;A&quot;, cex = 0.8, text.col = &quot;white&quot;, niceFacing = TRUE) highlight.sector(colnames(mat1), track.index = 1, col = &quot;green&quot;, text = &quot;B&quot;, cex = 0.8, text.col = &quot;white&quot;, niceFacing = TRUE) highlight.sector(colnames(mat2), track.index = 1, col = &quot;blue&quot;, text = &quot;C&quot;, cex = 0.8, text.col = &quot;white&quot;, niceFacing = TRUE) Figure 15.12: A more customized grouped Chord diagram. circos.clear() The implementation of multi-group Chord diagram is very simple. It can also be done by setting a proper sector order (by order argument) and a gap.after parameter. The previous example can be implemented without the group argument by the following code, but you need to manually calculate the proper value for gap.after. Setting group argument automatically does this for you. circos.par(gap.after = c(rep(1, 4), 5, rep(1, 4), 5, rep(1, 4), 5)) chordDiagram(mat, order = names(sort(group)), grid.col = grid.col) circos.clear() "],["a-complex-example-of-chord-diagram.html", "Chapter 16 A complex example of Chord diagram", " Chapter 16 A complex example of Chord diagram In this chapter, we demonstrate how to make a complex Chord diagram and how to customize additional tracks by visualizing chromatin state transitions as well as methylation changes. A chromatin state transition matrix shows how much a chromatin state in the genome has been changed from e.g. one group of samples to the other. The genomic regions for which the chromatin states change also have variable methylation patterns which may show interesting correspondance to chromatin states change. The data used in this post is processed from Roadmap dataset. The chromatin states are learned from five core chromatin marks. Roadmap samples are classified into two groups based on expression profile. In each group, a chromatin state is assigned to the corresponding genomic bin if it is recurrent in at least half of the samples in each group. The processed data can be set from https://jokergoo.github.io/circlize_book/data/chromatin_transition.RData. load(&quot;data/chromatin_transition.RData&quot;) In the RData file, there are three matrix: mat, meth_mat_1 and meth_mat_2 which are: mat: chromatin state transition matrix. Rows correspond to states in group 1 and columns correspond to group 2. The value in the matrix are total base pairs that transite from one state to the other. E.g. mat[\"TssA\", \"TxFlnk\"] is the total base pairs that have “TssA” state in samples in group 1 and transites to “TxFlnk” state in samples in group 2. On the diagonal are the regions where the states have not been changed in the two groups. meth_mat_1: mean methylation for each set of regions in group 1. E.g. meth_mat_1[\"TssA\", \"TxFlnk\"] is the mean methylation for the regions in group 1 that have “TssA” state in group 1 and “TxFlnk” state in group 2. meth_mat_2: mean methylation for each set of regions in group 2. E.g. meth_mat_2[\"TssA\", \"TxFlnk\"] is the mean methylation for the regions in group 2 that have “TssA” state in group 1 and “TxFlnk” state in group 2. mat[1:4, 1:4] ## TssA TssAFlnk TxFlnk Tx ## TssA 497200 79600 13400 1800 ## TssAFlnk 56400 233200 5000 800 ## TxFlnk 0 400 43000 1800 ## Tx 800 200 200 166400 meth_mat_1[1:4, 1:4] ## TssA TssAFlnk TxFlnk Tx ## TssA 0.1647232 0.1580874 0.1917435 0.2690045 ## TssAFlnk 0.2591677 0.2689880 0.3616242 0.3411387 ## TxFlnk NA 0.3697514 0.3360386 0.4752722 ## Tx 0.8268626 0.7822987 0.5799682 0.6595322 Normally, in majority in the genome, chromatin states of regions are not changed in the two groups, thus, we should only look at the regions in which the states are changed. # proportion of the unchanges states in the genome sum(diag(mat))/sum(mat) ## [1] 0.6192262 # remove the unchanged states diag(mat) = 0 When making the plot, actually rows and columns are different (because one is from group 1 and the other is from group 2), thus we give them different names and the original names are stored in all_states. all_states = rownames(mat) n_states = nrow(mat) rownames(mat) = paste0(&quot;R_&quot;, seq_len(n_states)) colnames(mat) = paste0(&quot;C_&quot;, seq_len(n_states)) dimnames(meth_mat_1) = dimnames(mat) dimnames(meth_mat_2) = dimnames(mat) Next we set the colors. colmat is the color of the links and the colors are represent as hexadecimal code. Links have more transparent (A0) if they contain few transitions (&lt; 70th percentile) because we don’t want it to disturb the visualization of the major transitions. state_col = c(&quot;TssA&quot; = &quot;#E41A1C&quot;, &quot;TssAFlnk&quot; = &quot;#E41A1C&quot;, &quot;TxFlnk&quot; = &quot;#E41A1C&quot;, &quot;Tx&quot; = &quot;#E41A1C&quot;, &quot;TxWk&quot; = &quot;#E41A1C&quot;, &quot;EnhG&quot; = &quot;#E41A1C&quot;, &quot;Enh&quot; = &quot;#E41A1C&quot;, &quot;ZNF/Rpts&quot; = &quot;#E41A1C&quot;, &quot;Het&quot; = &quot;#377EB8&quot;, &quot;TssBiv&quot; = &quot;#377EB8&quot;, &quot;BivFlnk&quot; = &quot;#377EB8&quot;, &quot;EnhBiv&quot; = &quot;#377EB8&quot;, &quot;ReprPC&quot; = &quot;#377EB8&quot;, &quot;ReprPCWk&quot; = &quot;#377EB8&quot;, &quot;Quies&quot; = &quot;black&quot;) # one for rows and one for columns state_col2 = c(state_col, state_col) names(state_col2) = c(rownames(mat), colnames(mat)) colmat = rep(state_col2[rownames(mat)], n_states) colmat = rgb(t(col2rgb(colmat)), maxColorValue = 255) qati = quantile(mat, 0.7) colmat[mat &gt; qati] = paste0(colmat[mat &gt; qati], &quot;A0&quot;) colmat[mat &lt;= qati] = paste0(colmat[mat &lt;= qati], &quot;20&quot;) dim(colmat) = dim(mat) Now we can use chordDiagram() function to make the plot. Here we set one pre-allocated track in which the methylation information will be added later. Also we only set annotationTrack to grid and the axes and sector labels will be customized in later code. chordDiagram() returns a data frame which contains coordinates for all links. circos.par(cell.padding = c(0, 0, 0, 0), points.overflow.warning = FALSE) cdm_res = chordDiagram(mat, col = colmat, grid.col = state_col2, directional = TRUE, annotationTrack = &quot;grid&quot;, big.gap = 10, small.gap = 1, preAllocateTracks = list(track.height = 0.1), link.target.prop = FALSE) head(cdm_res) ## rn cn value1 value2 o1 o2 x1 x2 col ## 1 R_1 C_1 0 0 15 13 431200 267200 #E41A1C20 ## 2 R_2 C_1 56400 56400 15 12 159800 267200 #E41A1CA0 ## 3 R_3 C_1 0 0 15 11 3600 210800 #E41A1C20 ## 4 R_4 C_1 800 800 15 10 34600 210800 #E41A1C20 ## 5 R_5 C_1 98200 98200 15 9 1411600 210000 #E41A1CA0 ## 6 R_6 C_1 0 0 15 8 139800 111800 #E41A1C20 Now the axes are added in the second track, also, the index of states are added at the center of the grids in the second track, if the degree for a sector is larger than 3 degrees. Note since there is already one pre-allocated track, the circular rectangles are in the second track (track.index = 2). circos.track(track.index = 2, panel.fun = function(x, y) { if(abs(CELL_META$cell.start.degree - CELL_META$cell.end.degree) &gt; 3) { sn = CELL_META$sector.index i_state = as.numeric(gsub(&quot;(C|R)_&quot;, &quot;&quot;, sn)) circos.text(CELL_META$xcenter, CELL_META$ycenter, i_state, col = &quot;white&quot;, font = 2, cex = 0.7, adj = c(0.5, 0.5), niceFacing = TRUE) xlim = CELL_META$xlim breaks = seq(0, xlim[2], by = 4e5) circos.axis(major.at = breaks, labels = paste0(breaks/1000, &quot;KB&quot;), labels.cex = 0.5) } }, bg.border = NA) On the top half, it is easy to see the proportion of different transitions in group 1 that come to every state in group 2. However, it is not straightforward for the states in the bottom half to see the proportion of different states in group 2 they transite to. This can be solved by adding small circular rectangles to represent the proportions. In following example, the newly added circular rectangles in the bottom half show e.g. how much the state 15 in group 1 has been transited to different states in group 2. Note from version 0.4.11, there is a new argument link.target.prop in chordDiagram(). It basically automatically applies following code. However, we still suggest users to read the following code because more tracks with similar code will be drawn later. for(i in seq_len(nrow(cdm_res))) { if(cdm_res$value1[i] &gt; 0) { circos.rect(cdm_res[i, &quot;x1&quot;], -mm_y(1), cdm_res[i, &quot;x1&quot;] - abs(cdm_res[i, &quot;value1&quot;]), -mm_y(2), col = state_col2[cdm_res$cn[i]], border = state_col2[cdm_res$cn[i]], sector.index = cdm_res$rn[i], track.index = 2) } } Methylation in each category is put on the most outside of the circle. On this track, we will put two paralle rectangles which are mean methylation and methylation difference between group 1 and group 2. Basically, on the bottom, we show meth_mat_2 - meth_mat_1 and on the top we show meth_mat_1 - meth_mat_2. The logic of following code is simple that it just simply adds rectangles repeatedly. abs_max = quantile(abs(c(meth_mat_1, meth_mat_2) - 0.5), 0.95, na.rm = TRUE) col_fun = colorRamp2(c(0.5 - abs_max, 0.5, 0.5 + abs_max), c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;)) col_fun2 = colorRamp2(c(-abs_max, 0, abs_max), c(&quot;green&quot;, &quot;white&quot;, &quot;orange&quot;)) ylim = get.cell.meta.data(&quot;ylim&quot;, sector.index = rownames(mat)[1], track.index = 1) y1 = ylim[1] + (ylim[2] - ylim[1])*0.4 y2 = ylim[2] for(i in seq_len(nrow(cdm_res))) { if(cdm_res$value1[i] &gt; 0) { circos.rect(cdm_res[i, &quot;x1&quot;], y1, cdm_res[i, &quot;x1&quot;] - abs(cdm_res[i, &quot;value1&quot;]), y1 + (y2-y1)*0.45, col = col_fun(meth_mat_1[cdm_res$rn[i], cdm_res$cn[i]]), border = col_fun(meth_mat_1[cdm_res$rn[i], cdm_res$cn[i]]), sector.index = cdm_res$rn[i], track.index = 1) circos.rect(cdm_res[i, &quot;x1&quot;], y1 + (y2-y1)*0.55, cdm_res[i, &quot;x1&quot;] - abs(cdm_res[i, &quot;value1&quot;]), y2, col = col_fun2(meth_mat_2[cdm_res$rn[i], cdm_res$cn[i]] - meth_mat_1[cdm_res$rn[i], cdm_res$cn[i]]), border = col_fun2(meth_mat_2[cdm_res$rn[i], cdm_res$cn[i]] - meth_mat_1[cdm_res$rn[i], cdm_res$cn[i]]), sector.index = cdm_res$rn[i], track.index = 1) circos.rect(cdm_res[i, &quot;x2&quot;], y1, cdm_res[i, &quot;x2&quot;] - abs(cdm_res[i, &quot;value1&quot;]), y1 + (y2-y1)*0.45, col = col_fun(meth_mat_2[cdm_res$rn[i], cdm_res$cn[i]]), border = col_fun(meth_mat_2[cdm_res$rn[i], cdm_res$cn[i]]), sector.index = cdm_res$cn[i], track.index = 1) circos.rect(cdm_res[i, &quot;x2&quot;], y1 + (y2-y1)*0.55, cdm_res[i, &quot;x2&quot;] - abs(cdm_res[i, &quot;value1&quot;]), y2, col = col_fun2(meth_mat_1[cdm_res$rn[i], cdm_res$cn[i]] - meth_mat_2[cdm_res$rn[i], cdm_res$cn[i]]), border = col_fun2(meth_mat_1[cdm_res$rn[i], cdm_res$cn[i]] - meth_mat_2[cdm_res$rn[i], cdm_res$cn[i]]), sector.index = cdm_res$cn[i], track.index = 1) } } circos.clear() Legends can be added according to instructions discussed in Section 4. "],["make-fun-of-the-package.html", "Chapter 17 Make fun of the package 17.1 A clock 17.2 A dartboard 17.3 Ba-Gua and Tai-Ji", " Chapter 17 Make fun of the package 17.1 A clock The first example is a clock. The key function here is circos.axis() (Figure 17.1). In the example, the whole circle only contains one sector in which major tick at 0 is overlapping with major tick at 12. Later we calculate the positions of the hour hand, the minute hand and the second hand based on current time when this Chapter is generated. The hands are drawn by arraws() function in the canvas coordinate. A real-time clock can be found at the Examples section in the help page of circos.axis(). circos.par(gap.degree = 0, cell.padding = c(0, 0, 0, 0), start.degree = 90) circos.initialize(&quot;a&quot;, xlim = c(0, 12)) circos.track(ylim = c(0, 1), bg.border = NA) circos.axis(major.at = 0:12, labels = NULL, direction = &quot;inside&quot;, major.tick.length = mm_y(2)) circos.text(1:12, rep(1, 12) - mm_y(6), 1:12, facing = &quot;downward&quot;) current.time = as.POSIXlt(Sys.time()) sec = ceiling(current.time$sec) min = current.time$min hour = current.time$hour sec.degree = 90 - sec/60 * 360 arrows(0, 0, cos(sec.degree/180*pi)*0.8, sin(sec.degree/180*pi)*0.8) min.degree = 90 - min/60 * 360 arrows(0, 0, cos(min.degree/180*pi)*0.7, sin(min.degree/180*pi)*0.7, lwd = 2) hour.degree = 90 - hour/12 * 360 - min/60 * 360/12 arrows(0, 0, cos(hour.degree/180*pi)*0.4, sin(hour.degree/180*pi)*0.4, lwd = 2) Figure 17.1: A clock. circos.clear() 17.2 A dartboard The second example is a dartboard. In Figure 17.2, tracks are assigned with different heights and each cell is initialized with different colors. The most inside green ring and red circle are plotted by draw.sector(). We use circos.trackText() to add labels because we know the global order of the labels. Now you can project the plot on your door and begin to play! sectors = 1:20 # just indicate there are 20 sectors circos.par(gap.degree = 0, cell.padding = c(0, 0, 0, 0), start.degree = 360/20/2, track.margin = c(0, 0), clock.wise = FALSE) circos.initialize(sectors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), sectors = sectors, bg.col = &quot;black&quot;, track.height = 0.15) circos.trackText(x = rep(0.5, 20), y = rep(0.5, 20), labels = c(13, 4, 18, 1, 20, 5, 12, 9, 14, 11, 8, 16, 7, 19, 3, 17, 2, 15, 10, 6), cex = 0.8, sectors = sectors, col = &quot;#EEEEEE&quot;, font = 2, facing = &quot;downward&quot;) circos.track(ylim = c(0, 1), sectors = sectors, bg.col = rep(c(&quot;#E41A1C&quot;, &quot;#4DAF4A&quot;), 10), bg.border = &quot;#EEEEEE&quot;, track.height = 0.05) circos.track(ylim = c(0, 1), sectors = sectors, bg.col = rep(c(&quot;black&quot;, &quot;white&quot;), 10), bg.border = &quot;#EEEEEE&quot;, track.height = 0.275) circos.track(ylim = c(0, 1), sectors = sectors, bg.col = rep(c(&quot;#E41A1C&quot;, &quot;#4DAF4A&quot;), 10), bg.border = &quot;#EEEEEE&quot;, track.height = 0.05) circos.track(ylim = c(0, 1), sectors = sectors, bg.col = rep(c(&quot;black&quot;, &quot;white&quot;), 10), bg.border = &quot;#EEEEEE&quot;, track.height = 0.375) draw.sector(center = c(0, 0), start.degree = 0, end.degree = 360, rou1 = 0.1, col = &quot;#4DAF4A&quot;, border = &quot;#EEEEEE&quot;) draw.sector(center = c(0, 0), start.degree = 0, end.degree = 360, rou1 = 0.05, col = &quot;#E41A1C&quot;, border = &quot;#EEEEEE&quot;) Figure 17.2: A dartboard. circos.clear() 17.3 Ba-Gua and Tai-Ji The third example is Ba-Gua. The key functions are circos.rect() and draw.sector() (Figure 17.3). Bagua was originated several thousands years ago in China. It is the source of almost all ancient Chinese philosophy. It abstracts the rule of universe into base signs and combination of the two basic signs generates the whole system of the universe. Inside Ba-Gua, these is the Tai-Ji. Tai-Ji refers to the most original state at the creation of the universe. In ancient Chinese philosophy system, at the very beginning, the whole world is a huge mass of air (chaos). Then the lighter air floated up and created sky while heavier sinked down and created ground. The upper world is called Yang and the bottom world is called Ying. And that is Tai-Ji. Looking at Tai-Ji, you can see there are two states interacting with each other. The white one and the black one gradually transformed into each other at the end. And in the center of white and black, the opposite color is generated. In real world, Taiji can represent all phenomenon that is of dualism. Such as male and female, correct and wrong. However things would change, good thing would become bad thing as time goes by, and bad thing would also turn into good according to how you look at the world. sectors = 1:8 circos.par(start.degree = 22.5, gap.degree = 6) circos.initialize(sectors, xlim = c(0, 1)) # yang yao is __ (a long segment) add_yang_yao = function() { circos.rect(0,0,1,1, col = &quot;black&quot;) } # yin yao is -- (two short segments) add_yin_yao = function() { circos.rect(0,0,0.45,1, col = &quot;black&quot;) circos.rect(0.55,0,1,1, col = &quot;black&quot;) } circos.track(ylim = c(0, 1), sectors = sectors, bg.border = NA, panel.fun = function(x, y) { i = get.cell.meta.data(&quot;sector.numeric.index&quot;) if(i %in% c(2, 5, 7, 8)) add_yang_yao() else add_yin_yao() }, track.height = 0.1) circos.track(ylim = c(0, 1), sectors = sectors, bg.border = NA, panel.fun = function(x, y) { i = get.cell.meta.data(&quot;sector.numeric.index&quot;) if(i %in% c(1, 6, 7, 8)) add_yang_yao() else add_yin_yao() }, track.height = 0.1) circos.track(ylim = c(0, 1), sectors = sectors, bg.border = NA, panel.fun = function(x, y) { i = get.cell.meta.data(&quot;sector.numeric.index&quot;) if(i %in% c(4, 5, 6, 7)) add_yang_yao() else add_yin_yao() }, track.height = 0.1) # the bottom of the most recent track r = get.cell.meta.data(&quot;cell.bottom.radius&quot;) - 0.1 # draw taiji, note default order is clock wise for `draw.sector` draw.sector(center = c(0, 0), start.degree = 90, end.degree = -90, rou1 = r, col = &quot;black&quot;, border = &quot;black&quot;) draw.sector(center = c(0, 0), start.degree = 270, end.degree = 90, rou1 = r, col = &quot;white&quot;, border = &quot;black&quot;) draw.sector(center = c(0, r/2), start.degree = 0, end.degree = 360, rou1 = r/2, col = &quot;white&quot;, border = &quot;white&quot;) draw.sector(center = c(0, -r/2), start.degree = 0, end.degree = 360, rou1 = r/2, col = &quot;black&quot;, border = &quot;black&quot;) draw.sector(center = c(0, r/2), start.degree = 0, end.degree = 360, rou1 = r/8, col = &quot;black&quot;, border = &quot;black&quot;) draw.sector(center = c(0, -r/2), start.degree = 0, end.degree = 360, rou1 = r/8, col = &quot;white&quot;, border = &quot;white&quot;) Figure 17.3: Ba-Gua and Tai-Ji. circos.clear() "]]
